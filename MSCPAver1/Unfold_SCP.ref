/****************************************************************************
   
            ������� ������ MSCP-A
            �������� �������, ����������� �������� ��� ���������������:
            UnfoldMain
            ������ ��:
            (e.Program)[NodeX]([PathOfX])[FullTree]> ==> [FullTree]
   
****************************************************************************/

$EXTERN prefal, c-prefal;
/* �� ������ basics.ref */
$EXTERN IfASubMultiSet, IfIncluded, CompareMultiSets, SubtractSetFromSet, FindMSIntersection, SubtractMS,
    SubtractEl,InsertInMultiSet,MergeSets,SetMinus,FindNode;
/* �� ������ basics.ref */
$EXTERN GenPath, DeleteNode, InsertNode, Collapse,SaveDriveMarker,Substitute, Map,
    DeleteMarkedEqs,GetParList, SubstInversion;
/* �� ������ basics.ref */
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, RenewIndices, FreshIndex, CurrentIndex, 
    MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/* �� ������ drive.ref */
$EXTERN ClashLeft,GenerateNextLevel,PostProcessPRTC,FormatStack,AssignTimeStamps, Drive, CheckNarrowingsScreening;
/* �� ������ AnalyzeFunDef.ref */
$EXTERN AssignFunctionFeatures;
/* �� ������ stack.ref */
$EXTERN YieldDecomposition;
/* �� ������ WordEquations.ref */
$EXTERN IfEqIsImplied, ImplyNEqsNew,NormalizeInequalityBlock;
/* �� ������ WordEqsCases.ref */
$EXTERN ProcessLinearInequality, ImplyNEqs;
/* �� ������ residual.ref */
$EXTERN YieldProgramGeneration;
/* �� ������ generalize.ref */
$EXTERN CheckNode4Generalization,CheckNode4Equivalence,NegativeCleaning, HomeomorphicEmb; /* ��������� ��� �����. */
/* �� ������ accessMSCP.ref */
$EXTERN AddNewLines, GetNodeStatus, PutNodeStatus, GetNodeName, PutNodeName, GetNodeRestrictions, PutNodeRestrictions, GetNodeConfig, PutNodeConfig,
    GetNodeStack, PutNodeStack, GetNodeEqs, PutNodeEqs, PutNodeNewEqs, GetNodeNewEqs, ReplaceNodeNewEqs,GetNodeLets, PutNodeLets, GetNodeChildren, PutNodeChildren,
    GenerateNewNode, GetNodeFullConfig, GetStackTop, DeleteNodeActiveData, GetNodeConfFromStack, PutNodeNewEqsToOld,
    GenerateFreshPRTC, ReplacePRTCAllEqs, NullifyNodeEqs, ReplaceNodeGenEqs, GetNodeGenericEqs, ReplaceNodeNegEqs,
    FormatPRTCToPrint, FormatTreeToPrint,RenameStackTop, PutNodeNegEqs, GetNodeNegEqs, SubstituteInNegative;

$ENTRY Go {
    , <Arg 1> : e.input0
    , <Arg 2> : e.output0
    , <GetInputFile ()e.input0> 
    : {(e.folder)e.input
    , <GetOutputFile (e.folder)(e.input)e.output0> : e.output
        =
        <Open 'w' 1 'mscplog'<SubdirSign>'trace_scp'>
        <Open 'w' 2 'mscplog'<SubdirSign>'generalizations'>
        <Open 'a' 3 'mscptest'<SubdirSign>'terms.txt'>
        <Collapse <TimeElapsed 0>>
        <RenewAllIndices>
        <c-prefal 
            (e.output)
            (
                (EXTERN )
                <TransformIntoRefal
                    <PredMainStep 
                        <TransformEncoding ()() <prefal e.input>>
                    >
                (Comment '/* This file was generated by MSCP at '<Time>'.*/')
               (Comment '/* Elapsed time of embeddings is '<FormatOut <Dg 'emb_time'>>'.*/') 
                (Comment '/* Elapsed time of generalizations is '<FormatOut <Dg 'mgu_time'>>'.*/') 
                >
            )<AAA>
            ('/verbose')
        >
        <Close 1><Close 2><Close 3>;
	'ERR'e.Errmessage = <Prout e.Errmessage>;
	};
}

/* ����������� ����������� ����� � ������ <�����>.<�����>. */
FormatOut {
    s.x = <Symb <Div s.x 1000>>'.'<Symb <Mod s.x 1000>>;
}

$ENTRY Delcomm {
     = ;
    (Comment e.1) e.2 = <Delcomm e.2>;
    (t.other e.1) e.2 = (t.other <Delcomm e.1>)<Delcomm e.2>;
}

$ENTRY SubdirSign {
*  Windows
*    = '\\';
* Linux
    = '/';
*  Macintosh (Apple)
*    = ':' ;
}

/*
    ������� ��������� ����� �������� �����.
   [string] => [string].ref 
*/
GetInputFile {
/* 0. �������� ���� �� �����. */
    (e.path)e.1 e.2 e.3
    , <SubdirSign> : e.2 
        = <GetInputFile (e.path e.1 e.2) e.3>;
/* 1. ���� ���� ����� ���������� ref, ������� ����� � ����� ������� ���, � ���� �� ���� ����, ��������� ��� ������� � �������� test. */
    (/* EMPTY */)e.1'.ref'
    , <ExistFile e.1'.ref'> : False
    , <ExistFile 'tests'<SubdirSign>e.1'.ref'> : True 
        = ('tests'<SubdirSign>)'tests'<SubdirSign> e.1'.ref';
/* 2. ���� ��� � ���������� ������� � ��������� ������ �����������, ������ �� ��������� ������� tests\test.ref */
    (e.path) /* EMPTY */
    , <ExistFile 'tests'<SubdirSign>'test.ref'> 
    : {True 
        = <Prout ' The input file is tests'<SubdirSign>'test.ref'> ('tests'<SubdirSign>)'tests'<SubdirSign>'test.ref';
	False 
	= 'ERR Please add the file test.ref to the subfolder '<SubdirSign>'tests.';
	};
/* 3. ���� ��� ������ � ����������� ref -- ��������� ��� ��� ����. */
    (e.path)e.1'.ref'	
	, <ExistFile e.path e.1'.ref'>
	: {True = (e.path)e.path e.1'.ref';
	False = 'ERR The input file does not exist.';
	};
/* 4. ���� ��� ������ � ������ ����������� -- ������� ��������� �� ������. */
    (e.path)e.1'.'e.2 = 'ERR The input file does not have the proper extension. Please use the input files with .ref extension.';
/* 5. ���� ��� ������ ��� ���������� -- ����������� ���������� ref. */
    (e.path)e.1 = <GetInputFile (e.path)e.1'.ref'>;
}

/* ������� ��������� ����� ��������� ����� (����� ���������� ���������). */
GetOutputFile {
/* 1. ���� ��� � ���������� ������� � ��������� ������ �����������, ���������� ��������� ���������� � ���� rsd_[��� �������� �����]. */
    (e.path)(e.path e.1)  = e.path'rsd_'e.1;
/* 2. ���� ��� ������ � ����������� ref -- ��������� ��� ��� ����. */
    (e.path)(e.1) e.2'.ref'
	, <SubdirSign> : e.SubD
	, e.2 : e.x2 e.SubD e.xx2 = e.2'.ref';
/* 2a. ���� ���� �� ��������� ����� ���� �� ������ -- �������� ���� ��� �������� �����.*/
    (e.path)(e.1) e.2'.ref'= e.path e.2'.ref';
/* 3. ���� ��� ������ � ������ ����������� -- ������� ��� ���������� � ����������� ���������� ref. */
    (e.path)(e.1)e.2'.'e.3 = <GetOutputFile (e.path)(e.1)e.2'.ref'>;
/* 4. ���� ��� ������ ��� ���������� -- ����������� ���������� ref. */
    (e.path)(e.1)e.2 = <GetOutputFile (e.path)(e.1)e.2'.ref'>;
}

/*
   $ENTRY Go {= <Open 'w' 1 'trace_scp'><Put 1 <HomeomorphicEmb ((par e 13 )'II'(par e 269 )'II'(par e 269 )(call (Mul1 14 )(args (arg ('*'(par e 269 ))'II'(par e 269 )))))
                (par e 13 )'III'(par e 542 )'III'(par e 542 )'III'(par e 542 )(call (Mul1 15 )(args (arg ('*'(par e 542 ))'III'(par e 542 ))))>><Close 1>;
            }
   
/*
   �������, ���������� ��� �������.
   varl_ind - ������� ���������� � �����;
   pari_ind - ������� ���������� ���� i;
   wevali_ind - ������� ��������� ���������� ���� i;
   time_stamp - ��������� ����� ������� ������� (��� ��������� �������); 
   emb_time - ����� �����, ����������� �� �������� ��������;
   mgu_time - ����� �����, ����������� �� ���������;
   eqsolv_time - ����� �����, ����������� �� ������� ��������� � ������.
*/
$ENTRY RenewAllIndices {
    = <Map RenewIndices 
        varl_ind time_stamp pare_ind part_ind pars_ind
        wevalt_ind wevale_ind wevals_ind emb_time mgu_time eqsolv_time Subtree prtc_ind
    >
    <Br 'Changes=F'><Br 'DriveType=C'>;
}

ProutByStrings {
    /* EMPTY */ = /* EMPTY */;
    t.1 e.1 = <Prout t.1><Prout><ProutByStrings e.1>;
}

/*******************************  ������� ������������� **************************************/

/* ������� ����������� ���������� ������� �� �������������� ������������� � ������������� prefal. */
TransformIntoRefal {
    /* EMPTY */ = /* EMPTY */;
    (Comment e.1) e.other = (Comment e.1)<TransformIntoRefal e.other>;
    ((ENTRY) t.FunctionName e.Definitions) e.other
        = ((ENTRY) (Go) <TransformDefinition e.Definitions>) <TransformIntoRefal e.other>;
    ((LOCAL) ((t.FunctionName (e.Set)) t.Number) e.Definitions) e.other
        = ((LOCAL) (<Implode <Explode t.FunctionName>'_'<SymbSet e.Set>'_'<Symb t.Number>>)
        <TransformDefinition e.Definitions>)<TransformIntoRefal e.other>;
    ((LOCAL) (t.FunctionName t.Number) e.Definitions) e.other
        = ((LOCAL) (<Implode <Explode t.FunctionName>'_'<Symb t.Number>>)
        <TransformDefinition e.Definitions>)<TransformIntoRefal e.other>;
}

/* ������� �������������� ������������� ����������� ������� � ������������� prefal. */
TransformDefinition {
    /* EMPTY */ = /* EMPTY */;
    ((e.Pars)'='(e.RightSide)) e.Other
        = ((<TransformExpressionToPrefal e.Pars>)'='(Expression <TransformExpressionToPrefal e.RightSide>))
        <TransformDefinition e.Other>;
}

/* ������� ��������� � ������������� prefal. */
TransformExpressionToPrefal {
    /* EMPTY */ = /* EMPTY */; 
    (Variable s.Sym t.name) e.other
    , <Type t.name>: 'N' 
        = (Variable <Explode s.Sym> <Implode <Symb t.name>>)<TransformExpressionToPrefal e.other>;
    (Variable s.Sym t.name) e.other
    , <Type t.name>: 'D' 
        = (Variable <Explode s.Sym> <Implode <Symb t.name>>)<TransformExpressionToPrefal e.other>;
    (Variable s.Sym t.name) e.other
        = (Variable <Explode s.Sym> t.name)<TransformExpressionToPrefal e.other>;
    s.Sym e.other
    , <Type s.Sym> : 
        {
        'W' e.1
            = (Word s.Sym)<TransformExpressionToPrefal e.other>;
        'N' e.1
            = (MacroDigit s.Sym)<TransformExpressionToPrefal e.other>;
        e.Z = s.Sym <TransformExpressionToPrefal e.other>;
        };
    (MacroDigit e.1) e.2 = (MacroDigit e.1)<TransformExpressionToPrefal e.2>;
    (Bracket' 'e.1) e.2 = (Bracket <TransformExpressionToPrefal e.1>)<TransformExpressionToPrefal e.2>;
    (Call ((t.fname (e.Set)) s.number) e.arg) e.other 
        = (Call <Implode <Explode t.fname>'_'<SymbSet e.Set>'_'<Symb s.number>> <TransformExpressionToPrefal e.arg>)<TransformExpressionToPrefal e.other>;
    (Call (t.fname s.number) e.arg) e.other = (Call <Implode <Explode t.fname>'_'<Symb s.number>> <TransformExpressionToPrefal e.arg>)<TransformExpressionToPrefal e.other>;
    (Condition (Expression e.1)(Pattern e.2)) e.Rest
        = (Condition (Expression <TransformExpressionToPrefal e.1>)(Pattern e.2))<TransformExpressionToPrefal e.Rest>;
}

SymbSet {
    /* EMPTY */ = /* EMPTY */;
    s.Num1 e.Other = <Symb s.Num1><SymbSet e.Other>;
}

/*
    ������� ������� ������������� �� ������� prefal �� ���������� ������ MSCP. 
   ((t.fname((e.LHS)e.RHS)^*)^*)((t.fname((e.LHS)e.RHS)^*)^*)e.ExpressionToTransform =>
   ((t.fname((e.LHS)e.RHS)^*)^*)[Stack]
*/
TransformEncoding {
/* 1. ������������� ���������. �������, ��� ������� ����� ���� ����, � ��� ���������� � ������� �����. */
    (e.functions)(e.entrypoints) = (e.functions)(((assign (var l (0)) (e.entrypoints)) ));
/* 2. ���������� ���������� � ������� ��������. */
    (e.functions)(e.entrypoints)(EXTERN e.ext) e.rest  = <TransformEncoding (e.functions)(e.entrypoints) e.rest>;
/* 3. ���������� ����������� ��� ����������� �������. */
    (e.functions)(e.entrypoints)(Comment e.ext) e.rest = <TransformEncoding (e.functions)(e.entrypoints) e.rest>;
/* 4. ������� ����� (������������) ���������� ��������. */
    (e.functions)(e.entrypoints)((ENTRY) t.fname e.CommentBefore ((e.lhs)'=' (Expression e.rhs))e.CommentAfter) e.rest
    , <Br 'entrypoint='<ConvertExpr Entry e.lhs>> : e.1
        = <TransformEncoding (e.functions)(e.entrypoints <ConvertExpr Entry e.rhs>) e.rest>;
/* 5. ������������� ����������� �������. */
    (e.functions)(e.entrypoints)((LOCAL) (e.fname) e.definition) e.rest
        = <TransformEncoding (e.functions (e.fname (Sents <ConvertDef e.definition>)))(e.entrypoints) e.rest>;

}

/* ������� �������� ��������� ��� ����������� � ����������� ������� �� ������� prefal �� ���������� ���� MSCP. */
ConvertDef {
    /* EMPTY */ = /* EMPTY */;
/* ����������� � ������������ ������� ���������. */
    (Comment e.x) e.rest = <ConvertDef e.rest>;
/* ����� � ������ ����� ���������� �� ���� ������ � ������ ��������������. */
    ((e.lhs) '=' (Expression e.rhs)) e.rest = ((<ConvertExpr Regular e.lhs>) <ConvertExpr Regular e.rhs>) <ConvertDef e.rest>;
}

/* ������� �������� ��������� ��� ��������� � ����������� ������� �� ������� prefal �� ���������� ���� MSCP. */
ConvertExpr {
    s.Mode (Comment e.x) e.rest = <ConvertExpr s.Mode e.rest>;
    s.Mode = /* EMPTY */;
/* 1. ������������� �������� � ����. */
    s.Mode s.1 e.1 = s.1 <ConvertExpr s.Mode e.1>;
/* 2. ����� �������������� ������ � ����. */
    s.Mode (Word e.1) e.2 = <ConvertExpr s.Mode e.1> <ConvertExpr s.Mode e.2>;
/* 3. ������������� ����������� ������. */
    s.Mode (Bracket e.1) e.2 = ('*'<ConvertExpr s.Mode e.1>) <ConvertExpr s.Mode e.2>;
/* 4. ������������� ���������� ������ �����. */
    s.Mode (Variable t.type t.name) e.2
    , s.Mode :
        {Regular = (var <Implode t.type> t.name) <ConvertExpr s.Mode e.2>; 
        Entry = (par <Implode t.type> t.name) <ConvertExpr s.Mode e.2>;
        };
/* 5. ����� �������������� ������ � ����. */
    s.Mode (MacroDigit s.digit)  e.2 = s.digit <ConvertExpr s.Mode e.2>; 
/* 6. ������������� ������ �������. */
    s.Mode (Call s.fname e.arg) e.rest
        = (call s.fname (args (arg <ConvertExpr s.Mode e.arg>))) <ConvertExpr s.Mode e.rest>; 
/* 7. � ��������� ������� - ��������� �� ������. */
    e.z = <Prout 'The input language contains non-basic primitives.'> <Recogn_Impossible>;
}


/*
   ������������� ���������� ������ UnfoldMain ����� ��� �������;
   ������ * ����� ����������� ������ ���������.
*/

/*
    Decode {
	= ;
	s.1 e.1 = s.1 <Decode e.1>;
	('*' e.1) e.2 = (<Decode e.1>) <Decode e.2>;
   } 
*/

/*******************************  ����������� ������� ������������� **************************************/


/*
	���������� ������������ �������� ������ � ��������� ������� �������.
	(e.Program)(((assign (var l t.n ) (e.expr)))) => (Node Finished (e.NodeData)(Children [Node]^*))
*/
PredMainStep {
    (e.Program)(((assign (var l t.n )(e.expr))))
    , <YieldDecomposition ((assign (var l t.n )(<AssignTimeStamps e.expr>)))> : e.Stack
    , <GetNodeConfFromStack <PutNodeStack <GenerateNewNode (0)> e.Stack>> : t.Root 
        = <YieldProgramGeneration 
            <UnfoldMain 
                (<AssignFunctionFeatures e.Program>) 
                t.Root
                ((0))
                t.Root
            >
        >;
}

/***********************************************************************************************************
     �������� ��� ���������. 
     <UnfoldMain (e.Program)[NodeX]([PathOfX])[FullTree]> ==> [FullTree]
     [Node]::= (Node t.Status t.Name ((e.Restrictions)(e.ConfigEquations)(e.LetExpressions)(e.FullConfig)(e.Stack))
     (Children [Node]^*))
     t.Status::= Driven | Undriven | Ready | Finished | (Looped e.NodeName)|ReadyForGenCheck
     [PathOfX]:: = ((0) [NodeName]^*)
     [FullTree]::= (Node t.Status (0) (e.NodeData)(Children [Node]^*))
************************************************************************************************************/


UnfoldMain {
/* 1. �������� ������� �� ����� �������� � ������������� ��������������. */
    t.Program (Node Finished t.RootName e.ConfNode)(t.RootName) (Node t.Status t.RootName e.Config) 
        = (Node Finished t.RootName e.ConfNode);
/* 2. ������������ � �������� ������������. */
    t.Program (Node Driven (e.RootName) (e.CurrConf) (Children )) (t.RootName) (Node t.Status t.RootName e.Config) 
        = Contradiction;
/* 3. ������������ � ���������� ������������ - ��������� � �� ��������. */
    t.Program t.Node (e.Path t.NodeName) t.Tree
    , <GetNodeStatus t.Node> : Driven
    , <GetNodeChildren t.Node> : 
        = 
        <UnfoldMain 
            t.Program <FindNode (e.Path) <DeleteNode (e.Path t.NodeName) t.Tree>>
            (e.Path)<DeleteNode (e.Path t.NodeName) t.Tree>
        >;
/* 4. ���������� ���������� � ���������� ������������ - ��������� � �� ��������. */
    t.Program t.Node t.Path t.Tree
    , <GetNodeStatus t.Node> : Finished
    , <FindAncestorPath t.Path <GetNodeName t.Node>> : t.NewPath
        = <UnfoldMain 
            t.Program <FindNode t.NewPath t.Tree>
            t.NewPath t.Tree
        >;
/* 5. ���� ���� ������� � ����� ������������ �������� ���� � ����������� �������, �������� ��� ������� ������ ����. */
    t.Program t.Node (e.Path) t.Tree
    , <GetNodeStatus t.Node> : Driven
    , <GetNodeChildren t.Node> : e.1 (e.PushChild ((Push)e.OtherConf)) e.2
    , <GetNodeRestrictions t.Node> : e.Restrictions
    , <GetNodeStack (e.PushChild ((Push)e.OtherConf))> : e.NewStack
    , <PutNodeStatus t.Node Ready> : t.Node1
    , <GetNodeConfFromStack <PutNodeStack t.Node1 e.NewStack>> : t.Node2
    , <PutNodeChildren t.Node2 > : t.ProcessedNode
        = 
        <UnfoldMain
            t.Program 
	    <Putout 1 'New stack is 'e.NewStack>
            <PrintIfTracing t.ProcessedNode>
            (e.Path) 
            <InsertNode t.ProcessedNode (e.Path)t.Tree>
        >;
/* 5�. ���� ���� ������� � ����� ������������ �������� ����, ������ ����������, ��� �� ��������	 
*/
/*
    	t.Program 
        (Node ReadyForGenCheck t.Nodename ((e.Restrictions) e.Conf) 
            (Children (Node Undriven t.ChildNode ((Always) e.NewConf)))
        )
        (e.Path) t.Tree 
		= 
		<UnfoldMain
			t.Program 
				<PrintIfTracing (Node Driven t.Nodename ((e.Restrictions) e.Conf)
                                                        (Children (Node Undriven t.ChildNode ((Always) e.NewConf))))>
				(e.Path) 
				<InsertNode (Node Driven t.Nodename ((e.Restrictions) e.Conf) 
                                    (Children (Node Undriven t.ChildNode ((Always) e.NewConf)))
                                    )(e.Path)t.Tree
                                >
		>; 
*/

/* 6. ���� ���� ������� ��� ���������, ��� ��� ������������ ��������):
	a) ��������� �������� � ������ �����,
	�
	�) ���� ��������� ������������ ����.
*/
    t.Program t.Node (e.Path) t.Tree
    , <CheckAlter <GetNodeStatus t.Node> EITHER Driven (Looped)> : True
        = 
        <UnfoldMain
            t.Program 
            <ChooseUndrivenNode 
                    t.Node
                    (e.Path) 
                    <InsertNode t.Node(e.Path)t.Tree>
            >
        >;
/* 7. ���������, ������� �� ������������, ����������� ������. */
/*
    	t.Program (Node Undriven t.Name (e.Conf (e.FullConf)(e.Stack))
		)(e.Path t.Last) t.Tree 
		= <UnfoldMain t.Program 
                        (Node 
                            <CheckNode4Equivalence 
                                (e.FullConf)
                                (e.Path)
                                t.Tree
                            > 
                            t.Name (e.Conf (e.FullConf)  (e.Stack))
                        )
                    (e.Path t.Last) t.Tree
                    >; 
*/
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : Undriven
    , <PutNodeStatus t.Node Ready> : t.ProcessedNode
        = <UnfoldMain 
            t.Program 
            t.ProcessedNode
            (e.Path t.Last) t.Tree
        >;
/* 8. ���� ���� ����������, �� ��� �� ��������. */
/*
    	t.Program (Node ReadyForGenCheck t.Name ((Always)e.Conf (e.FullConf)(e.Stack))
		)(e.Path t.Last) t.Tree 
		= <UnfoldMain t.Program 
                        (Node 
                            Ready 
                            t.Name ((Always)e.Conf (e.FullConf)  (e.Stack))
                        )
                    (e.Path t.Last) t.Tree
                    >;
*/
/* 9. ���������, �������� �� ���� _�����_ �������� ���������� �� ���������. */
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : ReadyForGenCheck
    , <GetNodeName t.Node> : t.Name
    , <GetNodeConfig t.Node> : e.FullConf
    , <GetNodeEqs t.Node> : e.Eqs
    , <GetNodeStack t.Node> : e.Stack
    , e.Stack : ((assign t.var ((call t.funname e.Arg)))e.ThisLevel) e.OtherLevels
    , <GetFunRecursionType t.funname t.Program> : s.Flag
    , <PutNodeStatus t.Node <CheckNode4Generalization t.Name s.Flag (e.Eqs)(e.FullConf)(e.Stack)(e.Path)t.Tree>> : t.ProcessedNode
        = <UnfoldMain t.Program 
            t.ProcessedNode
            (e.Path t.Last) t.Tree
        >;
/* 10�. ���� ���������� --- ������� ��������� ����� (������� ������������ ���� MGU ��� ������ � ��������� �� ������������).
   ����� ����� ���� ��� ������ ��������, ��� � ��������� �� ����������� (��������� ��� �����������). 
*/
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : 
            (Generalized (e.NodeName) 
                (Looped To t.AncestorName With e.Subs and (Generic e.GenGenEqs)(Negative e.NegGenEqs))(e.GenFullConf)(e.GenStack)(e.Assignments)(e.Children))
    , <FindNode (<GenPath t.AncestorName>) t.Tree> : t.AncestorNode
    , <GetNodeGenericEqs t.AncestorNode> : e.OldGenEqs
    , <GetNodeNegEqs t.AncestorNode> : e.OldNegEqs
    , <DeleteMarkedEqs ('S')<GetNodeNewEqs t.AncestorNode>> : e.OldNewEqs
    , <Substitute (<Substitute (<CutLetData e.Assignments>)e.Subs>)e.OldGenEqs e.OldNewEqs> : e.EqsSubstituted
    , <SubstituteInNegative (<Substitute (<CutLetData e.Assignments>)e.Subs>)e.OldNegEqs> : e.NEqsSubstituted
    , <SubstituteInNegative (<CutLetData e.Assignments>) e.NegGenEqs> : e.ProcNegEqs
    , <GetPreservedEqs 
        (e.OldGenEqs e.OldNewEqs)(e.EqsSubstituted)
        (e.GenGenEqs <GetNodeGenericEqs t.Node><GetNodeNewEqs t.Node>)
    > : e.CommonEqs
    , <ImplyNEqsNew 
        (<GetNodeNegEqs t.Node> e.ProcNegEqs)
        (<Zip (e.NEqsSubstituted)(e.OldNegEqs)>)
    > : s.Log e.CommonNeqs0
    , <SubstituteInNegative (<SubstInversion e.Subs>) e.CommonNeqs0> : e.CommonNeqs
    , <Putout 2 '  Checking embedding:'>
    <Putout 2 <AddNewLines <GetNodeNegEqs t.Node> e.ProcNegEqs>>
    <Putout 2 <AddNewLines e.NEqsSubstituted>> : /* */
    , <LogAnd <EquivalentEqSet (e.OldGenEqs e.OldNewEqs) e.CommonEqs> s.Log> :
        {'T'
        , <NullifyNodeEqs <DeleteNodeActiveData t.Node>> : t.DrivenNode
        , <GetNodeConfFromStack <PutNodeStack
            <PutNodeStatus <GenerateNewNode (e.NodeName 0)> (Looped To t.AncestorName With e.Subs)>
            e.GenStack>> : t.NewNode
        , <PutNodeChildren <PutNodeStatus t.DrivenNode Driven> t.NewNode e.Children> : t.Node3
        , <PutNodeLets t.Node3 (Let e.Assignments In (e.GenFullConf))> : t.ProcessedNode
		= <Putout 1><Putout 1 '  Equations are preserved:' <AddNewLines e.CommonEqs>>
                  <Putout 2><Putout 2 '  Equations are preserved:' <AddNewLines e.CommonEqs>>
                  <Putout 1><Putout 1 '  Inequalities are preserved:' <AddNewLines e.CommonNeqs>>
                  <Putout 2><Putout 2 '  Inequalities are preserved:' <AddNewLines e.CommonNeqs>>
                    <UnfoldMain t.Program 
                    <PrintIfTracing t.ProcessedNode>
                    (e.Path t.Last) t.Tree
                >;
        'F'
        , <PutNodeChildren 
                <ReplaceNodeNewEqs
                <PutNodeStatus 
                    <ReplaceNodeNegEqs 
                        <ReplaceNodeGenEqs t.AncestorNode e.CommonEqs <Substitute (<SubstInversion e.Subs>)e.GenGenEqs>> 
                        <NegativeCleaning e.CommonNeqs e.NegGenEqs>
                    > 
                Undriven>
                <MarkAllEqs ('S')e.OldNewEqs>>
        > : t.ProcessedAncNode
            = <Putout 1><Putout 1 '  Equations are cut:'<AddNewLines e.OldGenEqs e.OldNewEqs>>
                <Putout 1 '   to' <AddNewLines e.CommonEqs e.GenGenEqs>>
            <Putout 1><Putout 1 '  Inequalities are cut:'<AddNewLines e.OldNegEqs>>
                <Putout 1 '  to'<AddNewLines e.CommonNeqs e.NegGenEqs>>
            <Putout 2><Putout 2 '  Equations are cut:'<AddNewLines e.OldGenEqs e.OldNewEqs>>
                <Putout 2 '  to'<AddNewLines e.CommonEqs e.GenGenEqs>>
            <Putout 2><Putout 2 '  Inequalities are cut:'<AddNewLines e.OldNegEqs>>
                <Putout 2 '  to'<AddNewLines e.CommonNeqs e.NegGenEqs>>
            <UnfoldMain t.Program
                <PrintIfTracing t.ProcessedAncNode>
                (<GenPath t.AncestorName>) t.Tree
            >;
        };
/* 10�. ���� ���������� --- ��������� � ������������ ������ (��� ������� ������� ������������ ������ ���������). */
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : (Generalized t.AncestorName (UpperGeneralization With ((Generic e.NewEquations)(Negative e.Negs)))(e.GenFullConf)(e.GenStack)(e.Assignments)(e.Children))
    , t.AncestorName : (e.AncestorList)
    , <FindNode (<GenPath t.AncestorName>) t.Tree> : t.AncestorNode0
    , <FindGenerEqs 
        (<GetParList ()e.GenFullConf>)
        (e.Assignments)
        <GetNodeNewEqs t.AncestorNode0><GetNodeGenericEqs t.AncestorNode0>
    > : e.GenerEqs
    , <FindGenerNegative 
        (<GetParList ()e.GenFullConf>)
        (e.Assignments)
        <GetNodeNegEqs t.AncestorNode0>
    > : e.GenerNegative
    , <GetNegativeRestrictionsFromProgramRules t.Program e.GenFullConf> : e.RulesNegative
    , <NullifyNodeEqs t.AncestorNode0> : t.AncN1
    , <PutNodeLets t.AncN1 (Let e.Assignments In (e.GenFullConf))> : t.AncN2
    , <DeleteNodeActiveData t.AncN2> : t.AncN3
    , <PutNodeStatus t.AncN3 Driven> : t.AncN4
    , <GenerateNewNode (e.AncestorList 0)> : t.NewNode0
    , <PutNodeStatus t.NewNode0 Undriven> : t.NewNode1
    , <PutNodeStack t.NewNode1 e.GenStack> : t.NewNode2
    , <PutNodeConfig t.NewNode2 e.GenFullConf> : t.NewNode3
    , <PutNodeNegEqs 
        <PutNodeNewEqsToOld 
            <PutNodeNewEqs t.NewNode3 e.NewEquations e.GenerEqs>
        > 
        <NegativeCleaning e.Negs e.RulesNegative e.GenerNegative>
    > : t.ProcessedNewNode
    , <PutNodeChildren t.AncN4 t.ProcessedNewNode e.Children> : t.ProcessedAncNode
        =	
        <UnfoldMain t.Program
            <PrintIfTracing t.ProcessedAncNode>
            (<GenPath t.AncestorName>) t.Tree
        >;
/* 11. ���� ���� �� �������, ��������� ��������. */
/* �� ����� ������ ������ ����� ����� ���������� - �����: ���������� �������� ��� ����� ������. */
    t.Program t.Node (e.Path) t.Tree
    , <GetNodeStatus t.Node> : Ready
    , <GetNodeStack t.Node> : e.Stack
    , <GetNodeName t.Node> : t.Name
    , <GetStackTop e.Stack> : (call t.fdata (args (arg e.Arg)))
    , t.fdata : (t.fname t.timestamp)
    , <PutNodeStatus t.Node ReadyForGenCheck> : t.Node1
    , <YieldDriving 
        <FindFunctionDef t.Program (call t.fdata (args (arg e.Arg)))> 
        t.fdata 
        (e.Arg) 
        t.Name 
        t.Node
    > : e.NewChildren (e.RuleSet) t.NewStatus
    , <PutNodeStatus 
        <RenameStackTop 
            <PutNodeChildren 
                t.Node1 
                e.NewChildren
            > 
            t.fname (e.RuleSet)
        > 
        t.NewStatus
    > : t.ProcessedNode
        = <UnfoldMain 
            t.Program 
            <PrintIfTracing t.ProcessedNode>
            (e.Path) t.Tree
        >;

/* 12. ���������� � ���� ��������� - ��������� ������ ���� � ������ � �������� Finished. */
    t.Program t.Node (e.Path) t.Tree
    , <PutNodeStatus t.Node Finished> : t.ProcessedNode
        = <UnfoldMain 
            t.Program 
            t.ProcessedNode
            (e.Path) 
            <PrintIfTracing <InsertNode t.ProcessedNode(e.Path)t.Tree>>
        >;
}

GetFunRecursionType {
    ((t.fname (e.RSet)) t.timestamp)(e.1 (t.fname (Recursion s.Flag) e.OtherDef) e.2) = s.Flag;
    (t.fname t.timestamp)(e.1 (t.fname (Recursion s.Flag) e.OtherDef) e.2) = s.Flag;    
}

MarkAllEqs {
    (s.Log) = /* EMPTY */;
    (s.Log) (AreEqual (s.Log2)e.EqData) e.Rest
        = (AreEqual (s.Log)e.EqData)<MarkAllEqs (s.Log)e.Rest>;
}

/*
    ����� ����������� �������, ������� ����������� ���������.
   ([Program])[FunctionName] => ([e.FirstPattern])([e.FirstRightHandSide])((([Pattern])[RightHandSide])^*)
*/
FindFunctionDef {
    (e.ProgramBefore (t.fname e.Features (Sents e.Defs)) e.ProgramAfter) (call ((t.fname (e.RSet)) t.timestamp) e.Args)
        = <ExtractRuleSubset t.fname(e.Defs)>;
    (e.ProgramBefore (t.fname e.Features (Sents e.Defs)) e.ProgramAfter) (call (t.fname t.timestamp) e.Args)
        = <ExtractRuleSubset t.fname(e.Defs)>;
}

GetNegativeRestrictionsFromProgramRules {
    t.Program e.Config
    , <GetConfigCallsWithGaps e.Config> : e.Calls
    , <GetFailedClashes t.Program e.Calls> : e.NegativeData
         = <Putout 2 'Getting negative conditions from rules set:'>
         <Putout 2 <AddNewLines e.Calls>>
         <Putout 2 'produce conditions:'>
         <Putout 2 <AddNewLines e.NegativeData>>
            e.NegativeData;
}

GetFailedClashes {
    t.Program (s.FunName (s.Number e.FailedRules)(e.Arg)) e.Calls
    , <FindFunctionDef t.Program (call (s.FunName 0)(args (arg )))> : (s.PatternType)(e.LHS)(e.RHS)(e.Defs)
    , <FilterLHS (s.Number e.FailedRules)(1)(((s.PatternType)(e.LHS)e.RHS)e.Defs)> : e.LHSSet
    , <GetNegativeConditions (e.Arg)e.LHSSet> : e.NegativeConditions
        = <NormalizeInequalityBlock ( )e.NegativeConditions><GetFailedClashes t.Program e.Calls>;
    t.Program /* EMPTY */ = /* EMPTY */;
}

FilterLHS {
    (e.Sequence)(s.Current)(((s.PatternType)(e.LHS)e.RHS)e.Other)
    , e.Sequence
    : {
        e.Before s.Current e.Rest
            = ((s.PatternType)e.LHS)<FilterLHS (e.Rest)(<Add s.Current 1>)(e.Other)>;
        e.NotContainingCurrent
            = <FilterLHS (e.Sequence)(<Add s.Current 1>)(e.Other)>;
        };
    (e.Sequence)(s.Current)(/* EMPTY */) = /* EMPTY */;
}

GetNegativeConditions {
    (e.Expr)((s.Pattern)e.LHS)e.Other
        = (OR (s.Pattern)((e.Expr) to (e.LHS))) <GetNegativeConditions (e.Expr)e.Other>;
    (e.Expr) /* EMPTY */ = /* EMPTY */;
}

GetConfigCallsWithGaps {
    e.1 ('*'e.2)e.3 = <GetConfigCallsWithGaps e.1 e.2 e.3>;
    e.1 (call t.funname (args (arg e.Arg))) e.2
    , t.funname : ((s.InitName t.Rules) t.TimeStamp)
    , <SetMinus <GenNaturalSeq t.Rules> t.Rules>
    : {
        (t.SomeRuleNumber e.Other)
            = (s.InitName (t.SomeRuleNumber e.Other) (e.Arg)) <GetConfigCallsWithGaps e.Arg e.2>;
        (/* EMPTY */)
            = <GetConfigCallsWithGaps e.Arg e.2>;
    };
    e.Z = /* EMPTY */;
}

GenNaturalSeq {
    (e.Z s.Last)
        = <GenNaturalSeq Started (1)(s.Last)>;
    Started (e.Z s.Last)(s.Last) = (e.Z s.Last);
    Started (e.Z s.NotLast)(s.Last)
        = <GenNaturalSeq Started (e.Z s.NotLast <Add s.NotLast 1>)(s.Last)>;
}

ExtractRuleSubset {
    s.funname (((s.PatternType)(e.LHS)e.RHS)e.Defs) = (s.PatternType)(e.LHS)(e.RHS)(e.Defs);
    (s.funname (e.Numbers))(e.Defs)
    , <ExtractRuleSubset Started (1)(e.Numbers)e.Defs> : ((s.PatternType)(e.LHS)e.RHS)e.OtherDefs
        = (s.PatternType)(e.LHS)(e.RHS)(e.OtherDefs);
    Started (s.Num)(s.Num e.Other)(e.Rule)e.RestRules 
        = (e.Rule)<ExtractRuleSubset Started (<Add s.Num 1>)(e.Other)e.RestRules>;
    Started (s.Num)(s.OtherNum e.Other)(e.Rule)e.RestRules 
        = <ExtractRuleSubset Started (<Add s.Num 1>)(s.OtherNum e.Other)e.RestRules>;
    Started (s.Num)()e.RestRules = ;
}

/*
    ������ �������� ��������.
   ([Pattern])([RightHandSide])([FunctionDefinition]^*) [FunctionName] 
   ([FunctionArgument]) 
   [NodeName] ((e.Restrictions)(e.LetExpressions)(e.ConfigEquations)(e.FullConfig)(e.Stack)) =>
   [Tree]^+ (����� ������ - ����� [NodeName])
*/
YieldDriving {
    (e.LHS)((Restart))(e.RestDefs) t.fname (e.Config) t.NodeName ((e.Restrictions)(e.ConfigEquations)(e.FullConfig)(e.Stack)) 
        = <PushNodesScreening 
            <GenerateNextLevel 
                (1)(/* EMPTY */)(Unmod) t.NodeName (0) 
                ((e.Restrictions)(e.ConfigEquations)()(e.FullConfig)(e.Stack))
                (t.fname (Try e.Config)(SubsTo (Restart))(e.RestDefs))
                <PostProcessPRTC (/* EMPTY */)(/* EMPTY */)
                    <Drive ( )
                        <ClashLeft 0
                            <SaveDriveMarker 'dwevale_ind'> 
                            <SaveDriveMarker 'dwevalt_ind'>
                            <SaveDriveMarker 'dwevals_ind'>
                            <Putout 1 'New Clash: No ' <FreshIndex 'prtc_ind'>>
                            <Put 1
                                ((e.ConfigEquations (Desired))()()(((e.Config) to (e.LHS))(Delayed ))('T'))
                            >
                            <Putout 1>
                    >>
                >
            >
        >;
    (s.PatternType)(e.LHS)(e.RHS)(e.RestDefs) t.fname (e.Config) t.NodeName t.WholeNode
    , <Br 'PatternType='s.PatternType> : e.Z
    , <GetNodeEqs <PutNodeNewEqsToOld t.WholeNode>> : e.ConfigEquations
    , <ReplacePRTCAllEqs <GenerateFreshPRTC (e.LHS)(e.Config)> e.ConfigEquations> : t.PRTC
        = <PushNodesScreening
            <GenerateNextLevel 
                (1)(/* EMPTY */)(Unmod)t.NodeName (0) 
                t.WholeNode
                (t.fname (Try e.Config)(SubsTo e.RHS)(e.RestDefs))
                <PostProcessPRTC (/* EMPTY */)(/* EMPTY */)
                    <RenewIndices 'vare_ind'>
                    <RenewIndices 'vars_ind'>
                    <RenewIndices 'vart_ind'>
                    <Drive s.PatternType ()
                        <ClashLeft s.PatternType 0
                            <SaveDriveMarker 'dpare_ind'> 
                            <SaveDriveMarker 'dpart_ind'>
                            <SaveDriveMarker 'dpars_ind'>
                            <Putout 1 'New Clash: No '<FreshIndex 'prtc_ind'>>
                            <Putout 1 <FormatPRTCToPrint t.PRTC>>
                            t.PRTC
                            <Putout 1>
                        >
                    >
                >
                ReadyForGenCheck
            >
        >;
}

PushNodesScreening {
    e.Children (e.Rules) t.Status
    , <GetReadyNodes e.Children> :
        {t.Ch1 t.Ch2 e.ChOther
            = <AnalyzePushNodes (t.Ch1 t.Ch2 e.ChOther) e.Children> (e.Rules) t.Status;
        e.Z /* ���������� push-�������� ����� �������� ������ 2. */
            = e.Children (e.Rules) t.Status;
        };
}

GetReadyNodes {
    t.Node e.Other
    , <GetNodeStatus t.Node> : 
        {Ready
            = t.Node <GetReadyNodes e.Other>;
        e.Z
            = <GetReadyNodes e.Other>;
        };
    /* EMPTY */ = /* EMPTY */;
}

AnalyzePushNodes {
    (t.Node) e.Children = e.Children;
    (t.Node e.Other) e.Children
    , <GetNodeRestrictions t.Node> : e.Restrs
    , <CheckNarrowingsScreening (e.Restrs)(e.Other)> :
        { t.OtherNode
        , e.Children : e.Ch1 t.Node e.Ch2
            =  <AnalyzePushNodes (e.Other) e.Ch1 e.Ch2>;
        /* EMPTY */
            = <AnalyzePushNodes (e.Other) e.Children>;
        };
}

EquivalentEqSet {
    (e.1)e.1 = 'T';
    (e.1 t.1 e.2) e.3 t.1 e.4 = <EquivalentEqSet (e.1 e.2) e.3 e.4>;
    (e.1 (AreEqual t.Log1 t.LHS t.RHS) e.2) e.3 (AreEqual t.Log2 t.RHS t.LHS) e.4 
        = <EquivalentEqSet (e.1 e.2) e.3 e.4>;
    e.Other = 'F';
}

EquivalentNEqSet {
    ( )e.1 = 'T';
    (e.1 t.1 e.2) e.3 t.1 e.4 = <EquivalentNEqSet (e.1 e.2) e.3 e.4>;
    e.Other = 'F';
}

FindEqsIntersection {
    (e.OldEqs)(e.SubbedEqs)e.NewEqs
        = <FindEqsIntersection Started (<Zip (e.OldEqs)(e.SubbedEqs)>)e.NewEqs>;
    Started ((t.0 t.1) e.1) e.20 t.1 e.21 = t.0 <FindEqsIntersection Started (e.1)e.20 t.1 e.21>;
    Started ((t.0 t.1) e.1) e.2
    , <IfEqIsImplied t.1(e.2)> :
        {'F'
            = <FindEqsIntersection Started (e.1)e.2>;
        'T'
            = t.0 <FindEqsIntersection Started (e.1)e.2>;
        };
    Started (/* EMPTY */) e.2 = /* EMPTY */;
}

$ENTRY Zip {
    (t.1 e.1)(t.2 e.2) = (t.1 t.2)<Zip (e.1)(e.2)>;
    ()() = ;
}

GetOldVariant {
    t.0 t.1 = t.0;
    t.0 = ;
}

/*
    ����� ��������� ���� � ������������� ����������.
   �������� �� ������ �������� ������ ������ ������� ��, ������� ����� ������ Driven, Undriven ��� Ready.
   ���� ����� ������ ���, ��������� ������ ������� � ������ � �������� Finished.
   ������ �������:
   [ParentNode]([ChildNode]^*)[path][tree]=>[Node][path][tree]
*/
$ENTRY ChooseSuccessorNode {
/* 1. � ������ ������� ��� �������� ������, � ������� �� �������� ��������� -> ������� ���������� ��� Finished */
    t.Node (/* EMPTY */)(e.Path)(e.Tree)
    , <PutNodeStatus t.Node Finished> : t.Node1
    , <PutNodeChildren t.Node1> : t.PreProcNode
    , t.Node :
        { (Node e.XXX)
        , <PutNodeLets t.PreProcNode (Subtree <FreshIndex 'Subtree'>)> : t.Node3
        , <DeleteNodeActiveData t.Node3> : t.ProcessedNode 
            = <Collapse <Br 'Subtree'<Symb <CurrentIndex 'Subtree'>>'='t.Node1>>
                t.ProcessedNode(e.Path)<InsertNode t.ProcessedNode(e.Path)(e.Tree)>;
        (t.OtherType e.XXX)
            = t.PreProcNode(e.Path)<InsertNode t.PreProcNode(e.Path)(e.Tree)>;
        };
/* 2. ��������� �������� ���� ����� ������ ������������ (��� ������������). ������������� ������. */
    t.Node (t.ChildNode e.OtherChildren)(e.Path)(e.Tree)
    , <CheckAlter <GetNodeStatus t.ChildNode> EITHER Finished (Looped)> : True
        = <ChooseSuccessorNode t.Node (e.OtherChildren)(e.Path)(e.Tree)>;
/* 3. ������� ������� �������� ���� - ���������� ��� � ���� �� ����. */
    t.Node (t.ChildNode e.OtherChildren)(e.Path)(e.Tree)
    , <GetNodeName t.ChildNode> : t.ChildName
        = t.ChildNode <ProlongPath (e.Path) t.ChildName>(e.Tree);
}

CheckAlter {
    (t.x e.x) EITHER e.1 (t.x) e.2 = True;
    t.x EITHER e.1 t.x e.2 = True;
    t.x EITHER e.1 = False;
}

IsRoot {
    t.Node
    , <GetNodeName t.Node> : (t.Single)
        = True;
    t.Node = False;
}


/*
    ����� ���������� ������ �� �������� ������������� �������� (���� ����� ����� ����)
   ������ �������
   (Node e.Node)(e.Path)(e.Tree)=>[nodeData][path][tree]
*/
$ENTRY ChooseUndrivenNode {
/* 1. ������� �������, �� ������� �� ����������� �������� � �������� �� ����������� ��������� - ���������� ��. */
    t.Node t.Path t.Tree
    , <CheckAlter <GetNodeStatus t.Node> EITHER Undriven Ready> : True 
        = t.Node t.Path t.Tree;
/* 2. �������� ����� �� ����� ������ � ������� ��� ��� Finished. ���������� ������. */
    t.Node t.Path t.Tree
    , <IsRoot t.Node> : True
    , <GetNodeStatus t.Node> : Finished
        = t.Node t.Path t.Tree;
/* 3. ���� ������� ����� ������ Finished, � ��� �� ������, ���������� ����� �� �� ��������. */
    t.Node t.Path t.Tree
    , <CheckAlter <GetNodeStatus t.Node> EITHER Finished (Looped)> : True
    , <ShortenPath t.Path> : t.NewPath
        = <ChooseUndrivenNode <FindNode t.NewPath t.Tree>t.NewPath t.Tree>;
/*
   4. ���� ������� ����� ������ Driven, �������� �� ����� �� �������� Driven, Undriven ��� Ready � ���������� ����� �� ���
   ���� �� ����� ����� ���, �� ��� ������� �������� ������ Finished. 
*/
    t.Node t.Path t.Tree
    , <GetNodeStatus t.Node> : Driven
    , <GetNodeChildren t.Node> : e.Children
        = <ChooseUndrivenNode <ChooseSuccessorNode t.Node (e.Children)t.Path t.Tree>>;
}

/*
    �������� ��� �������-������ � ���� �� ����� �� �� �������. ��������� ���� �� ������� ������.
   ([path])t.NodeName => ([path])
*/
FindAncestorPath {
    (e.PathBefore t.NodeName e.PathAfter)t.NodeName = (e.PathBefore);
}

FindNodePath {
    (e.PathBefore t.NodeName e.PathAfter)t.NodeName = (e.PathBefore t.NodeName);
}

ProlongPath {
    (e.PathBefore) t.NodeName = (e.PathBefore t.NodeName);
}

ShortenPath {
    (e.PathBefore t.NodeName) = (e.PathBefore);
}

/* ��� ������ �� ������������ ��������������. */
Recogn_Impossible {
    aaa = ;
}

/* ��� �������������. */
AAA {
    e.1, A : B = e.1;
}

/* ��� �������������. */
PrintIfTracing {
*   e.1 = e.1;
    e.1 = e.1 <Putout 1 <FormatTreeToPrint e.1>>;
}
CutLetData {
    /* EMPTY */ = /* EMPTY */;
    (t.NodeName t.Assignment) e.Rest 
        = t.Assignment <CutLetData e.Rest>;
}

FindGenerNegative {
    (e.Parameters)((t.NodeNum (assign t.newpar((par e.oldpar))))e.OtherAssignments) e.Neg
        = <FindGenerNegative (e.Parameters)(e.OtherAssignments)
            <SubstituteInNegative ((assign (par e.oldpar)(t.newpar)))e.Neg>>;
    (e.Parameters)((t.NodeNum (assign e.OtherExpr))e.OtherAssignments) e.Equations
        = <FindGenerNegative (e.Parameters)(e.OtherAssignments)e.Equations>;
    (e.Parameters)()(OR (s.Log)e.Clashes)e.OtherOR
    , <CheckParSet(e.Parameters)(e.Clashes)> : 
        {'T'
            = (OR (s.Log)e.Clashes)<FindGenerNegative (e.Parameters)()e.OtherOR>;
        'F'
            = <FindGenerNegative (e.Parameters)()e.OtherOR>;
        };
    (e.Parameters)() = ;
}

FindGenerEqs {
    (e.Parameters)((t.NodeNum (assign t.newpar((par e.oldpar))))e.OtherAssignments) e.Equations
        = <FindGenerEqs (e.Parameters)(e.OtherAssignments) <Substitute ((assign (par e.oldpar)(t.newpar)))e.Equations>>;
    (e.Parameters)((t.NodeNum (assign e.OtherExpr))e.OtherAssignments) e.Equations
        = <FindGenerEqs (e.Parameters)(e.OtherAssignments)e.Equations>;
    (e.Parameters)()(AreEqual (s.Log)(e.LHS)(e.RHS))e.OtherEqs
    , <CheckParSet(e.Parameters) e.LHS e.RHS>: 
        {'T'
            = (AreEqual ('F')(e.LHS)(e.RHS))<FindGenerEqs (e.Parameters)()e.OtherEqs>;
        'F'
            = <FindGenerEqs (e.Parameters)(/* EMPTY */)e.OtherEqs>;
        };
    (e.Parameters)(/* EMPTY */) = /* EMPTY */;
}

CheckParSet {
    (e.Parameters) = 'T';
    (e.Parameters) ('*' e.1) e.2 = <LogAnd <CheckParSet (e.Parameters)e.1><CheckParSet (e.Parameters)e.2>>;
    (e.Parameters) (call t.fname (args (arg e.1))) e.2 = <LogAnd <CheckParSet (e.Parameters)e.1><CheckParSet (e.Parameters)e.2>>;
    (e.Parameters) (par e.par) e.2
    , <InSet (par e.par)e.Parameters> :
        {'T'
            = <CheckParSet (e.Parameters)e.2>;
        'F' = 'F';
        };
    (e.Parameters) ((e.1) to (e.2)) e.Other = <CheckParSet (e.Parameters) e.1 e.Other>;    
    (e.Parameters) t.1 e.1 = <CheckParSet (e.Parameters)e.1>;
}

InSet {
    t.1 e.1 t.1 e.2 = 'T';
    t.1 e.Other = 'F';
}

FindNEqsIntersection {
    (e.1 t.1 e.2) e.11 t.1 e.12 = <FindNEqsIntersection (e.1 e.2) e.11 t.1 e.12>;
    (t.1 e.1) e.2 = <PreserveNeqIfImplied t.1 (e.2)><FindNEqsIntersection (e.1)e.2>;
    () e.2 = /* EMPTY */;
}

PreserveNeqIfImplied {
    (OR ('T')((e.RHS) to (e.LHS))) e.Neqs
    , <ProcessLinearInequality ((e.RHS) to (e.LHS))> : (OR t.SingleIneq)
        = <PreserveNeqIfImplied (OR ('T') t.SingleIneq)e.Neqs>;
    t.1 e.N1 t.1 e.N2 = t.1;
    e.Z = /* EMPTY */;
}

GetPreservedEqs {
    (e.OldEqs)(e.SubEqs)(e.NewEqs)
     = <FindEqsIntersection 
        (e.OldEqs)(e.SubEqs) e.NewEqs 
        >;
}