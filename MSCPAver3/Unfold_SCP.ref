/****************************************************************************

            ГЛАВНЫЙ МОДУЛЬ MSCP-A!
            Содержит функцию, реализующую основной шаг суперкомпиляции
            Unfold_SCP
            Формат ее:
            (e.Program)[NodeX]([PathOfX])[FullTree]> ==> [FullTree]

****************************************************************************/
$EXTERN prefal, c-prefal;
/*из модуля basics.ref*/
$EXTERN IfASubMultiSet, IfIncluded, CompareMultiSets, SubtractSetFromSet, FindMSIntersection, SubtractMS,SubtractEl,InsertInMultiSet,MergeSets,FindNode;
/*из модуля basics.ref*/
$EXTERN GenPath,Collapse;
/*из модуля basics.ref*/
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, FindTerm, RenewIndices, FreshIndex, CurrentIndex, MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/*из модуля drive.ref*/
$EXTERN ClashLeft,GenerateNextLevel,PostProcessPRTC,FormatStack,AssignTimeStamps;
/*из модуля stack.ref*/
$EXTERN YieldDecomposition;
/*из модуля residual.ref*/
$EXTERN YieldProgramGeneration;
/*из модуля generalize.ref*/
$EXTERN CheckNode4Generalization,CheckNode4Equivalence,FoldStackIntoConf,HomeomorphicEmb; /*последняя для теста*/
/*из модуля accessMSCP.ref*/
$EXTERN GetNodeStatus, PutNodeStatus, GetNodeName, PutNodeName, GetNodeRestrictions, PutNodeRestrictions, GetNodeConfig, PutNodeConfig,
    GetNodeStack, PutNodeStack, GetNodeEqs, PutNodeEqs, GetNodeLets, PutNodeLets, GetNodeChildren, PutNodeChildren,
    GenerateNewNode, GetNodeFullConfig, GetStackTop, DeleteNodeActiveData;

XXX { = ;}

/* Файл, из которого читает этот модуль - test.ref, порождаемый batch-файлом MSCP из того файла, который ему подали на вход*/
$ENTRY Go {, <Arg 1> : e.input0,
    <Arg 2> : e.output0,
    <GetInput e.input0> : e.input,
    <GetOutput (e.input)e.output0> : e.output =
        <Open 'w' 1 'trace_scp'>
        <Open 'w' 2 'generalizations'>
        <Collapse <TimeElapsed 0>>
        <RenewAllIndices>
        <c-prefal 
            (e.output)
            (
                (EXTERN )
                <TransformIntoRefal
                    <PredMainStep 
                        <TransformEncoding ()() <prefal e.input>>
                    >
                (Comment '/*This file is generated by MSCP at '<Time>'.*/')
                (Comment '/*Elapsed time of embeddings is '<FormatOut <Dg 'emb_time'>>'.*/')
                (Comment '/*Elapsed time of generalizations is '<FormatOut <Dg 'mgu_time'>>'.*/')
                >
            )
            ('/verbose')
        >
        <Close 1><Close 2>;
}

/*Преобразует натуральное число в формат <число>.<число>.*/
FormatOut {
    s.x = <Div s.x 1000>'.'<Mod s.x 1000>;
}


Delcomm {
 = ;
(Comment e.1) e.2 = <Delcomm e.2>;
(t.other e.1) e.2 = (t.other <Delcomm e.1>)<Delcomm e.2>;
}

/*Функция получения имени входного файла.
[string] => [string].ref*/
GetInput {
/*1. Если имя в параметрах запуска в командной строке отсутствует, файлом по умолчанию считаем test.ref*/
     = 'test.ref';
/*2. Если имя задано с расширением ref -- оставляем его как есть*/
     e.1'.ref' = e.1'.ref';
/*3. Если имя задано с другим расширением -- удаляем это расширение и приписываем расширение ref*/
     e.1'.'e.2 = e.1'.ref';
/*4. Если имя задано без расширения -- приписываем расширение ref*/
     e.1 = e.1'.ref';
}

/*Функция получения имени выходного файла (файла остаточной программы)*/
GetOutput {
/*1. Если имя в параметрах запуска в командной строке отсутствует, остаточная программа помещается в файл rsd_[имя входного файла]*/
    (e.1) = 'rsd_'e.1;
/*2. Если имя задано с расширением ref -- оставляем его как есть*/
    (e.1)e.2'.ref' = e.2'.ref';
/*3. Если имя задано с другим расширением -- удаляем это расширение и приписываем расширение ref*/
    (e.1)e.2'.'e.3 = e.2'.ref';
/*4. Если имя задано без расширения -- приписываем расширение ref*/
    (e.1)e.2 = e.2'.ref';
}

/*$ENTRY Go {= <Open 'w' 1 'trace_scp'><Put 1 <HomeomorphicEmb ((par e 13 )'II'(par e 269 )'II'(par e 269 )(call (Mul1 14 )(args (arg ('*'(par e 269 ))'II'(par e 269 )))))
                (par e 13 )'III'(par e 542 )'III'(par e 542 )'III'(par e 542 )(call (Mul1 15 )(args (arg ('*'(par e 542 ))'III'(par e 542 ))))>><Close 1>;
            }

/*Функция, обнуляющая все индексы.
varl_ind - индексы переменных в стеке
pari_ind - индексы параметров типа i
wevali_ind - индексы строковых переменных типа i
time_stamp - временные метки вызовов функций (для отношения Турчина) 
emb_time - общее время, затраченное на проверку вложений
mgu_time - общее время, затраченное на обобщения
eqsolv_time - общее время, затраченное на решение уравнений в словах
*/
RenewAllIndices {
= <RenewIndices 'varl_ind'><RenewIndices 'time_stamp'><RenewIndices 'pare_ind'><RenewIndices 'part_ind'><RenewIndices 'pars_ind'>
<RenewIndices 'wevalt_ind'><RenewIndices 'wevale_ind'><RenewIndices 'wevals_ind'><RenewIndices 'emb_time'><RenewIndices 'mgu_time'>
<RenewIndices 'eqsolv_time'><RenewIndices 'Subtree'>;
}

ProutByStrings {
     = ;
    t.1 e.1 = <Prout t.1><Prout><ProutByStrings e.1>;
}

/*******************************  Функции перекодировки **************************************/


/*Перевод предложений остаточной функции из промежуточного представления в представление prefal*/
TransformIntoRefal {
     = ;
    (Comment e.1) e.other = (Comment e.1)<TransformIntoRefal e.other>;
    ((ENTRY) t.FunctionName e.Definitions) e.other = ((ENTRY) (Go) <TransformDefinition e.Definitions>) <TransformIntoRefal e.other>;
    ((LOCAL) (t.FunctionName t.Number) e.Definitions) e.other = ((LOCAL) (<Implode <Explode t.FunctionName><Symb t.Number>>)
        <TransformDefinition e.Definitions>)<TransformIntoRefal e.other>;
}

/*Перевод промежуточного представления определения функции в представление prefal*/
TransformDefinition {
    =;
    ((e.Pars)'='(e.RightSide)) e.Other = ((<TransformExpressionToPrefal e.Pars>)'='(Expression <TransformExpressionToPrefal e.RightSide>))
                                        <TransformDefinition e.Other>;
}

/*Перевод выражения в представление prefal*/
TransformExpressionToPrefal {
     = ; 
    (Variable s.Sym t.name) e.other, <Type t.name>: 'N' = (Variable <Explode s.Sym> <Implode <Symb t.name>>)<TransformExpressionToPrefal e.other>;
    (Variable s.Sym t.name) e.other, <Type t.name>: 'D' = (Variable <Explode s.Sym> <Implode <Symb t.name>>)<TransformExpressionToPrefal e.other>;
    (Variable s.Sym t.name) e.other = (Variable <Explode s.Sym> t.name)<TransformExpressionToPrefal e.other>;
/*Здесь недоделка - нужно приписывать тег Word, чтобы не путать символы и макросимволы*/
    s.Sym e.other = s.Sym <TransformExpressionToPrefal e.other>;
    (Bracket' 'e.1)e.2 = (Bracket <TransformExpressionToPrefal e.1>)<TransformExpressionToPrefal e.2>;
    (Call (t.fname s.number) e.arg) e.other = (Call <Implode <Explode t.fname><Symb s.number>> <TransformExpressionToPrefal e.arg>)<TransformExpressionToPrefal e.other>;
}

/*Базовая функция перекодировки из формата prefal во внутренний формат MSCP. 
((t.fname((e.LHS)e.RHS)^*)^*)((t.fname((e.LHS)e.RHS)^*)^*)e.ExpressionToTransform =>
((t.fname((e.LHS)e.RHS)^*)^*)[Stack]
*/
TransformEncoding {
/*1. Перекодировка завершена. Считаем, что входная точка лишь одна, и она помещается в вершину стека*/
        (e.functions)(e.entrypoints) = (e.functions)(((assign (var l (0)) (e.entrypoints)) ));
/*2. Игнорируем информацию о внешних функциях*/
	(e.functions)(e.entrypoints)(EXTERN e.ext) e.rest  = <TransformEncoding (e.functions)(e.entrypoints) e.rest>;
/*3. Игнорируем комментарии вне определений функций*/
	(e.functions)(e.entrypoints)(Comment e.ext) e.rest = <TransformEncoding (e.functions)(e.entrypoints) e.rest>;
/*4. Входную точку (единственную) запоминаем отдельно*/
	(e.functions)(e.entrypoints)((ENTRY) t.fname e.CommentBefore ((e.lhs)'=' (Expression e.rhs))e.CommentAfter) e.rest=
		<TransformEncoding (e.functions)(e.entrypoints <ConvertEntry e.rhs>) e.rest>;
/*5. Перекодировка определения функции*/
	(e.functions)(e.entrypoints)((LOCAL) (e.fname) e.definition) e.rest =
                                   <TransformEncoding (e.functions (e.fname (Sents <ConvertDef e.definition>)))(e.entrypoints) e.rest>;

}

/*Функция перевода кодировки для предложений в определении функции из формата prefal во внутренний язык MSCP*/
ConvertDef {
	=;
/*Комментарии в определениях функций удаляются*/
	(Comment e.x) e.rest = <ConvertDef e.rest>;
/*Левые и правые части помещаются за одни скобки и каждая перекодируется*/
	((e.lhs) '=' (Expression e.rhs)) e.rest = ((<ConvertExpr e.lhs>) <ConvertExpr e.rhs>) <ConvertDef e.rest>;
}

/*Функция перевода кодировки для выражения в определении функции из формата prefal во внутренний язык MSCP*/
ConvertExpr {
	=;
/*1. перекодировка констант в себя*/
	s.1 e.1 = s.1 <ConvertExpr e.1>;
/*2. слово перекодируется просто в себя*/
	(Word e.1)   e.2 = e.1 <ConvertExpr e.2>;
/*3. перекодировка структурных скобок*/
	(Bracket e.1) e.2 = ('*'<ConvertExpr e.1>) <ConvertExpr e.2>;
/*4. перекодировка переменных разных типов*/
	(Variable 's' t.name) e.2 = (var s t.name) <ConvertExpr e.2>; 
	(Variable 'e' t.name) e.2 = (var e t.name) <ConvertExpr e.2>;
	(Variable 't' t.name) e.2 = (var t t.name) <ConvertExpr e.2>;
/*5. число перекодируется просто в себя*/
	(MacroDigit s.digit)  e.2 = s.digit <ConvertExpr e.2>; 
/*6. перекодировка вызова функции*/
	(Call s.fname e.arg) e.rest = (call s.fname (args (arg <ConvertExpr e.arg>))) <ConvertExpr e.rest>; 
/*7. в остальных случаях - сообщение об ошибке*/
	e.z = <Prout 'The input language contains non-basic primitives.'> <Recogn_Impossible>;
}

/*Функция перевода кодировки из формата prefal во внутренний язык MSCP для выражения, стоящего в вызове ENTRY.
Отличается от предыдущей тем, что "переменные", которые в нём указаны, суть параметры*/
ConvertEntry {
	(Comment e.x) e.rest = <ConvertEntry e.rest>;
	=;
	s.1 e.1 = s.1 <ConvertEntry e.1>;
	(Word e.1)    e.2 = e.1 <ConvertEntry e.2>;
	(Bracket e.1) e.2 = ('*'<ConvertEntry e.1>) <ConvertEntry e.2>;
	(Variable 's' t.name) e.2 = (par s t.name) <ConvertEntry e.2>; 
	(Variable 'e' t.name) e.2 = (par e t.name) <ConvertEntry e.2>;
	(Variable 't' t.name) e.2 = (par t t.name) <ConvertEntry e.2>;
	(MacroDigit s.digit)  e.2 = s.digit <ConvertEntry e.2>; 
	(Call s.fname e.arg) e.rest = (call s.fname (args (arg <ConvertEntry e.arg>))) <ConvertEntry e.rest>; 
	e.z = <Prout 'The input language contains non-basic primitives.'> <Recogn_Impossible>;
}

/*
Декодирование результата работы UnfoldMain перед его выдачей
символ * после открывающей скобки удаляется */
/*Decode {
	= ;
	s.1 e.1 = s.1 <Decode e.1>;
	('*' e.1) e.2 = (<Decode e.1>) <Decode e.2>;
}*/
/*******************************  Закончились функции перекодировки **************************************/

/*
	Производим декомпозицию входного вызова и запускаем главную функцию
	(e.Program)(((assign (var l t.n ) (e.expr)))) => (Node Finished (e.NodeData)(Children [Node]^*))
*/
PredMainStep {
(e.Program)(((assign (var l t.n )(e.expr))))=<YieldProgramGeneration 
						<UnfoldMain 
						(e.Program) 
                                                (Node Undriven (0) 
							(()()()<FormatStack <YieldDecomposition
                                                        (((assign (var l t.n )(<AssignTimeStamps e.expr>))))>>)
						)
						((0))
						(Node Undriven (0) ())
						>
                                                >;
}

/***********************************************************************************************************
* Основной шаг 
  <UnfoldMain (e.Program)[NodeX]([PathOfX])[FullTree]> ==> [FullTree]
  [Node]::= (Node t.Status t.Name ((e.Restrictions)(e.ConfigEquations)(e.LetExpressions)(e.FullConfig)(e.Stack))
  (Children [Node]^*))
  t.Status::= Driven | Undriven | Ready | Finished | (Looped e.NodeName)|ReadyForGenCheck
  [PathOfX]:: = ((0) [NodeName]^*)
  [FullTree]::= (Node t.Status (0) (e.NodeData)(Children [Node]^*))
************************************************************************************************************/

UnfoldMain {
	/*1. Корневая вершина не имеет потомков с непрогнанными конфигурациями*/
	t.Program (Node Finished t.RootName e.ConfNode)(t.RootName) (Node t.Status t.RootName e.Config) 
		= (Node Finished t.RootName e.ConfNode);
	/*2. противоречие в корневой конфигурации*/
	t.Program (Node Driven (e.RootName) (e.CurrConf) (Children )) (t.RootName) (Node t.Status t.RootName e.Config) 
		= Contradiction;
	/*3. противоречие в некорневой конфигурации - переходим к ее родителю*/
	t.Program (Node Driven t.NodeName (e.CurrConf) (Children ))(e.Path t.NodeName) t.Tree 
		= <UnfoldMain t.Program <FindNode (e.Path) <DeleteNode (e.Path t.NodeName) t.Tree>>
				(e.Path)<DeleteNode (e.Path t.NodeName) t.Tree>>;
	/*4. завершение вычислений в некорневой конфигурации - переходим к ее родителю*/
	t.Program t.Node t.Path t.Tree,
	<GetNodeStatus t.Node> : Finished,
	<FindAncestorPath t.Path <GetNodeName t.Node>> : t.NewPath
		= <UnfoldMain t.Program <FindNode t.NewPath t.Tree>
				t.NewPath t.Tree>;
	/*5. если узел прогнан и имеет единственный дочерний узел с вытолкнутым вызовом, заменяем его данными данные узла
	25.12.16. Вообще-то здесь он не единственный, и это не оптимально: надо, как и в SCP4, делать ветвление ниже по
        рестрикциям.*/
	t.Program t.Node (e.Path) t.Tree,
        <GetNodeStatus t.Node> : ReadyForGenCheck,
        <GetNodeChildren t.Node> : e.1 (e.PushChild ((Push)e.OtherConf)) e.2,
        <GetNodeRestrictions t.Node> : (e.Restrictions),
        <GetNodeStack (e.PushChild ((Push)e.OtherConf))> : t.NewStack,
        <FoldStackIntoConf t.NewStack> : e.NewFullConfig,
        <PutNodeStatus t.Node Ready> : t.Node1,
        <PutNodeStack t.Node1 t.NewStack> : t.Node2,
	<PutNodeChildren t.Node2 > : t.Node3,
        <PutNodeConfig t.Node3 (e.NewFullConfig)> : t.ProcessedNode
		= 
		<UnfoldMain
			t.Program 
				<PrintIfTracing t.ProcessedNode>
				(e.Path) 
				<InsertNode t.ProcessedNode (e.Path)t.Tree>
		>;
        /*5а. если узел прогнан и имеет единственный дочерний узел, причем транзитный, его не обобщаем
	*/
/*	t.Program 
        (Node ReadyForGenCheck t.Nodename ((e.Restrictions) e.Conf) 
            (Children (Node Undriven t.ChildNode ((Always) e.NewConf)))
        )
        (e.Path) t.Tree 
		= 
		<UnfoldMain
			t.Program 
				<PrintIfTracing (Node Driven t.Nodename ((e.Restrictions) e.Conf)
                                                        (Children (Node Undriven t.ChildNode ((Always) e.NewConf))))>
				(e.Path) 
				<InsertNode (Node Driven t.Nodename ((e.Restrictions) e.Conf) 
                                    (Children (Node Undriven t.ChildNode ((Always) e.NewConf)))
                                    )(e.Path)t.Tree
                                >
		>;*/
	/*6. если узел прогнан или оказалось, что его конфигурация повторна):
	a) вставляем прогонку в дерево путей
	и
	б) ищем ближайший непрогнанный узел
	*/
	t.Program t.Node (e.Path) t.Tree,
        <GetNodeStatus t.Node> : Driven
		= 
		<UnfoldMain
			t.Program 
			<ChooseUndrivenNode 
				t.Node
				(e.Path) 
				<InsertNode t.Node(e.Path)t.Tree>
			>
		>;
				
	t.Program t.Node(e.Path) t.Tree,
        <GetNodeStatus t.Node> : (Looped e.LoopData)
		= 
		<UnfoldMain
			t.Program 
			<ChooseUndrivenNode 
				t.Node
				(e.Path) 
				<InsertNode t.Node(e.Path)t.Tree>
			>
		>;
	/*7. Проверяем, имеются ли конфигурации, повторяющие данную*/
/*	t.Program (Node Undriven t.Name (e.Conf (e.FullConf)(e.Stack))
		)(e.Path t.Last) t.Tree 
		= <UnfoldMain t.Program 
                        (Node 
                            <CheckNode4Equivalence 
                                (e.FullConf)
                                (e.Path)
                                t.Tree
                            > 
                            t.Name (e.Conf (e.FullConf)  (e.Stack))
                        )
                    (e.Path t.Last) t.Tree
                    >;*/
        t.Program t.Node (e.Path t.Last) t.Tree,
        <GetNodeStatus t.Node> : Undriven,
        <PutNodeStatus t.Node Ready> : t.ProcessedNode
		= <UnfoldMain t.Program 
                        t.ProcessedNode
                    (e.Path t.Last) t.Tree
                    >;
        /*8. Если узел транзитный, мы его не обобщаем*/
/*	t.Program (Node ReadyForGenCheck t.Name ((Always)e.Conf (e.FullConf)(e.Stack))
		)(e.Path t.Last) t.Tree 
		= <UnfoldMain t.Program 
                        (Node 
                            Ready 
                            t.Name ((Always)e.Conf (e.FullConf)  (e.Stack))
                        )
                    (e.Path t.Last) t.Tree
                    >;
*/
	/*9. Проверяем, является ли узел _после_ прогонки кандидатом на обобщение*/
	t.Program t.Node (e.Path t.Last) t.Tree,
        <GetNodeStatus t.Node> : ReadyForGenCheck,
        <GetNodeName t.Node> : t.Name,
        <GetNodeConfig t.Node> : e.FullConf,
        <GetNodeStack t.Node> : t.Stack,
        <PutNodeStatus t.Node <CheckNode4Generalization t.Name (e.FullConf)t.Stack(e.Path)t.Tree>> : t.ProcessedNode
		= <UnfoldMain t.Program 
                        t.ProcessedNode
                    (e.Path t.Last) t.Tree
                    >;
	/*10а. Узел обобщается --- вариант обобщения снизу (верхняя конфигурация есть MGU для нижней с точностью до переименовки)*/
	t.Program t.Node (e.Path t.Last) t.Tree,
        <GetNodeStatus t.Node> : (Generalized t.SomeName (Looped e.LoopData)(e.GenFullConf)(e.GenStack)(e.Assignments)(e.Children)),
        <GetNodeName t.Node> : (e.Name),
        <DeleteNodeActiveData t.Node> : t.Node1,
        <PutNodeEqs t.Node1 ()> : t.Node2,
	<PutNodeStatus t.Node2 Driven> : t.Node3,
        <GenerateNewNode (e.Name 0)> : t.NewNode0,
        <PutNodeStatus t.NewNode0 (Looped e.LoopData)> : t.NewNode1,
        <PutNodeStack t.NewNode1 (e.GenStack)> : t.NewNode2,
        <PutNodeConfig t.NewNode2 (e.GenFullConf)> : t.ProcessedNewNode,
        <PutNodeChildren t.Node3 t.ProcessedNewNode e.Children> : t.Node4,
        <PutNodeLets t.Node4 (Let e.Assignments In (e.GenFullConf))> : t.ProcessedNode
		= <UnfoldMain t.Program 
                    <PrintIfTracing t.ProcessedNode>
                    (e.Path t.Last) t.Tree
                >;
	/*10б. Узел обобщается --- обобщение в конфигурации предка (все прежние потомки конфигурации предка удаляются)*/
	t.Program t.Node (e.Path t.Last) t.Tree, 
        <GetNodeStatus t.Node> : (Generalized t.AncestorName (UpperGeneralization With (e.NewEquations))(e.GenFullConf)(e.GenStack)(e.Assignments)(e.Children)),
        t.AncestorName : (e.AncestorList),
        <FindNode (<GenPath t.AncestorName>) t.Tree> : t.AncestorNode0,
        <PutNodeEqs t.AncestorNode0 ()> : t.AncN1,
        <PutNodeLets t.AncN1 (Let e.Assignments In (e.GenFullConf))> : t.AncN2,
        <DeleteNodeActiveData t.AncN2> : t.AncN3,
        <PutNodeStatus t.AncN3 Driven> : t.AncN4,
        <GenerateNewNode (e.AncestorList 0)> : t.NewNode0,
        <PutNodeStatus t.NewNode0 Undriven> : t.NewNode1,
        <PutNodeStack t.NewNode1 (e.GenStack)> : t.NewNode2,
        <PutNodeConfig t.NewNode2 (e.GenFullConf)> : t.NewNode3,
        <PutNodeEqs t.NewNode3 (e.NewEquations)> : t.ProcessedNewNode,
        <PutNodeChildren t.AncN4 t.ProcessedNewNode e.Children> : t.ProcessedAncNode
        	=	
		<UnfoldMain t.Program
                    <PrintIfTracing t.ProcessedAncNode>
                    (<GenPath t.AncestorName>) t.Tree
		>;
	/*11. Если узел не прогнан, запускаем прогонку*/
	/*На самом нижнем уровне самая левая переменная - вызов: производим прогонку для этого вызова */
	t.Program t.Node (e.Path) t.Tree, 
                <GetNodeStatus t.Node> : Ready,
                <GetNodeStack t.Node> : t.Stack,
                <GetNodeName t.Node> : t.Name,
                <GetStackTop t.Stack> : (call t.fdata (args (arg e.Arg))),
                t.fdata : (t.fname t.timestamp),
                <PutNodeStatus t.Node ReadyForGenCheck> : t.Node1,
                <PutNodeChildren 
			t.Node1 
			<YieldDriving 
				<FindFunctionDef t.Program t.fdata> 
				t.fname 
				(e.Arg) 
				t.Name 
				(<GetNodeFullConfig t.Node>)
			>
		> : t.ProcessedNode
		= <UnfoldMain t.Program 
                    <PrintIfTracing t.ProcessedNode>
                    (e.Path) t.Tree
                >;

	/*12. вычисления в узле завершены - вставляем данный узел в дерево с пометкой Finished*/
	t.Program t.Node (e.Path) t.Tree,
            <PutNodeStatus t.Node Finished> : t.ProcessedNode
		= <UnfoldMain 
			t.Program 
			t.ProcessedNode
			(e.Path) 
			<PrintIfTracing <InsertNode t.ProcessedNode(e.Path)t.Tree>>
		>;
}


/*Поиск определения функции, которую планируется выполнить
([Program])[FunctionName] => ([e.FirstPattern])([e.FirstRightHandSide])((([Pattern])[RightHandSide])^*)
*/
FindFunctionDef {
	(e.ProgramBefore (t.fname (Sents ((e.LHS)e.RHS) e.RestDefs)) e.ProgramAfter) (t.fname t.timestamp) =
		(e.LHS)(e.RHS)(e.RestDefs);
}

/*Запуск процесса прогонки
([Pattern])([RightHandSide])([FunctionDefinition]^*) [FunctionName] 
([FunctionArgument]) 
[NodeName] ((e.Restrictions)(e.LetExpressions)(e.ConfigEquations)(e.FullConfig)(e.Stack)) =>
[Tree]^+ (набор вершин - дочек [NodeName])
*/
YieldDriving {
(e.LHS)(e.RHS)(e.RestDefs) t.fname (e.Config) t.NodeName ((e.Restrictions)(e.ConfigEquations)(e.FullConfig)(e.Stack)) 
    = <GenerateNextLevel t.NodeName (0) 
				((e.Restrictions)(e.ConfigEquations)()(e.FullConfig)(e.Stack))
				(t.fname (Try e.Config)(SubsTo e.RHS)(e.RestDefs))
				<PostProcessPRTC ()()
					<ClashLeft <Putout 1 'New Clash:'><Put 1((e.ConfigEquations (Desired))()()(((e.Config) to (e.LHS))(Delayed ))('T'))><Putout 1>>
				>
			>;
}


/*Удаление вершины из дерева по ее пути
[path][tree]^+ =>[tree]
[path]::=([nodename]+) (порядок - от корня к вершине, путь до которой указан)
[tree]::=(Node [NodeStatus] [NodeName] (([restriction]^*|Always|Push) ([equation]^*)([LetExpressions]^*)([FullConfiguration])([Stack]))
(Children [tree]^*))
*/
DeleteNode {
/*1. От пути осталось просто имя вершины - мы на нужном уровне в дереве, удаляем ее*/
	(t.NodeName) e.NodesBefore (Node t.Status t.NodeName e.Config) e.NodesAfter = 
		e.NodesBefore e.NodesAfter;
/*2. На каждом новом этапе ищем предка удаляемой вершины, оставляем всех его соседей как есть, и переходим к его потомкам*/
	(t.AncestorNodeName e.NextAncestors) 
	e.NodesBefore (Node t.Status t.AncestorNodeName e.Config (Children e.Children)) e.NodesAfter
		= 
		e.NodesBefore 
		(Node t.Status t.AncestorNodeName e.Config (Children <DeleteNode (e.NextAncestors) e.Children>)) 
		e.NodesAfter;
}

/*Вставка вершины с обновленными данными в дерево
[NewNode][path][Tree]^+ =>[tree]
[path] - позиция, на которую вставляется [NewNode]. Считаем, что она в дереве [Tree] всегда существует. 
*/
InsertNode {
/*1. От пути осталось просто имя вершины - мы на нужном уровне в дереве, вставляем новые данные*/
	(Node e.NewConf)(t.NodeName) e.NodesBefore(Node t.Status t.NodeName e.Config) e.NodesAfter = 
		e.NodesBefore (Node e.NewConf) e.NodesAfter;
/*2. На каждом новом этапе ищем предка изменяемой вершины, оставляем всех его соседей как есть, и переходим к его потомкам*/
	(Node e.NewConf)
	(t.AncestorNodeName e.NextAncestors) 
	e.NodesBefore(Node t.Status t.AncestorNodeName e.Config (Children e.Children)) e.NodesAfter
		= 
		e.NodesBefore 
		(Node t.Status t.AncestorNodeName e.Config (Children <InsertNode (Node e.NewConf)(e.NextAncestors) e.Children>)) 
		e.NodesAfter;
}

/*Выбор дочернего узла с незавершенной разверткой.
Выбираем из списка дочерних вершин данной вершины те, которые имеют статус Driven, Undriven или Ready
Если таких вершин нет, вставляем данную вершину в дерево с пометкой Finished
Формат функции
[ParentNode]([ChildNode]^*)[path][tree]=>[Node][path][tree]
*/
ChooseSuccessorNode {
/*1. У данной вершины нет дочерних вершин, в которых не доделана развертка -> вершина помечается как Finished*/
	t.Node ()(e.Path)(e.Tree),
	<PutNodeStatus t.Node Finished> : t.Node1,
	<PutNodeChildren t.Node1> : t.Node2,
	<PutNodeLets t.Node2 (Subtree <FreshIndex 'Subtree'>)> : t.Node3,
	<DeleteNodeActiveData t.Node3> : t.ProcessedNode =
		<Collapse <Br 'Subtree'<Symb <CurrentIndex 'Subtree'>>'='t.Node1>>
		t.ProcessedNode(e.Path)<InsertNode t.ProcessedNode(e.Path)(e.Tree)>;
/*2. Очередной дочерний узел имеет статус завершенного (или зацикленного). Рассматриваем другие*/
	t.Node (t.ChildNode e.OtherChildren)(e.Path)(e.Tree),
	<CheckAlter <GetNodeStatus t.ChildNode> EITHER Finished (Looped)> : True =
		<ChooseSuccessorNode t.Node (e.OtherChildren)(e.Path)(e.Tree)>;
/*3. Нашелся искомый дочерний узел - возвращаем его и путь до него*/
	t.Node (t.ChildNode e.OtherChildren)(e.Path)(e.Tree),
	<GetNodeName t.ChildNode> : t.ChildName
	=
		t.ChildNode <ProlongPath (e.Path) t.ChildName>(e.Tree);
}

CheckAlter {
	(t.x e.x) EITHER e.1 (t.x) e.2 = True;
	t.x EITHER e.1 t.x e.2 = True;
	t.x EITHER e.1 = False;
}

IsRoot {
	t.Node,
	<GetNodeName t.Node> : (t.Single) = True;
	t.Node = False;
}


/*Выбор ближайшего соседа со статусом незавершенной прогонки (если такой сосед есть)
Формат функции
(Node e.Node)(e.Path)(e.Tree)=>[nodeData][path][tree]
*/
ChooseUndrivenNode {
/*1. нашлась вершина, на которой не запускалась прогонка и проверка на повторность состояния - возвращаем ее*/
	t.Node t.Path t.Tree,
	<CheckAlter <GetNodeStatus t.Node> EITHER Undriven Ready> : True =
		t.Node t.Path t.Tree;
/*2. Алгоритм дошёл до корня дерева и пометил его как Finished. Возвращаем корень*/
	t.Node t.Path t.Tree,
	<IsRoot t.Node> : True,
	<GetNodeStatus t.Node> : Finished
		= t.Node t.Path t.Tree;
/*4. Если вершина имеет статус Finished, и это не корень, продолжаем поиск от ее родителя*/
	t.Node t.Path t.Tree,
	<CheckAlter <GetNodeStatus t.Node> EITHER Finished (Looped)> : True,
	<ShortenPath t.Path> : t.NewPath
		= <ChooseUndrivenNode <FindNode t.NewPath t.Tree>t.NewPath t.Tree>;
/*6. Если вершина имеет статус Driven, выбираем ее дочку со статусом Driven, Undriven или Ready и продолжаем поиск от нее
если же таких дочек нет, то эта вершина получает статус Finished*/
	t.Node t.Path t.Tree,
	<GetNodeStatus t.Node> : Driven,
	<GetNodeChildren t.Node> : e.Children =
		<ChooseUndrivenNode <ChooseSuccessorNode t.Node (e.Children)t.Path t.Tree>>;
}

/*Известно имя вершины-предка и путь от корня до ее потомка. Построить путь до вершины предка
([path])t.NodeName => ([path])
*/
FindAncestorPath {
    (e.PathBefore t.NodeName e.PathAfter)t.NodeName = (e.PathBefore);
}

FindNodePath {
    (e.PathBefore t.NodeName e.PathAfter)t.NodeName = (e.PathBefore t.NodeName);
}

ProlongPath {
	(e.PathBefore) t.NodeName = (e.PathBefore t.NodeName);
}

ShortenPath {
	(e.PathBefore t.NodeName) = (e.PathBefore);
}

/*Для выхода по невозможному отождествлению*/
Recogn_Impossible {
aaa = ;
}

/*Для трассировщика*/
AAA {
e.1 = e.1;
}

/*Для трассировщика*/
PrintIfTracing {
*	e.1 = e.1;
	e.1 = <Put 1 e.1>;
}
