/****************************************************************************

            ÃËÀÂÍÛÉ ÌÎÄÓËÜ MSCP-A!
            Ñîäåðæèò ôóíêöèþ, ðåàëèçóþùóþ îñíîâíîé øàã ñóïåðêîìïèëÿöèè
            Unfold_SCP
            Ôîðìàò åå:
            (e.Program)[NodeX]([PathOfX])[FullTree]> ==> [FullTree]

****************************************************************************/
$EXTERN prefal, c-prefal;
/*èç ìîäóëÿ basics.ref*/
$EXTERN IfASubMultiSet, IfIncluded, CompareMultiSets, SubtractSetFromSet, FindMSIntersection, SubtractMS,SubtractEl,InsertInMultiSet,MergeSets,FindNode;
/*èç ìîäóëÿ basics.ref*/
$EXTERN GenPath,Collapse;
/*èç ìîäóëÿ basics.ref*/
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, FindTerm, RenewIndices, FreshIndex, CurrentIndex, MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/*èç ìîäóëÿ drive.ref*/
$EXTERN ClashLeft,GenerateNextLevel,PostProcessPRTC,FormatStack,AssignTimeStamps;
/*èç ìîäóëÿ stack.ref*/
$EXTERN YieldDecomposition;
/*èç ìîäóëÿ residual.ref*/
$EXTERN YieldProgramGeneration;
/*èç ìîäóëÿ generalize.ref*/
$EXTERN CheckNode4Generalization,CheckNode4Equivalence,FoldStackIntoConf,HomeomorphicEmb; /*ïîñëåäíÿÿ äëÿ òåñòà*/
/*èç ìîäóëÿ accessMSCP.ref*/
$EXTERN GetNodeStatus, PutNodeStatus, GetNodeName, PutNodeName, GetNodeRestrictions, PutNodeRestrictions, GetNodeConfig, PutNodeConfig,
    GetNodeStack, PutNodeStack, GetNodeEqs, PutNodeEqs, GetNodeLets, PutNodeLets, GetNodeChildren, PutNodeChildren,
    GenerateNewNode, GetNodeFullConfig, GetStackTop, DeleteNodeActiveData;

XXX { = ;}

/* Ôàéë, èç êîòîðîãî ÷èòàåò ýòîò ìîäóëü - test.ref, ïîðîæäàåìûé batch-ôàéëîì MSCP èç òîãî ôàéëà, êîòîðûé åìó ïîäàëè íà âõîä*/
$ENTRY Go {, <Arg 1> : e.input0,
    <Arg 2> : e.output0,
    <GetInputFile ()e.input0> : (e.folder) e.input,
    <GetOutputFile (e.folder)(e.input)e.output0> : e.output =
        <Open 'w' 1 'trace_scp'>
        <Open 'w' 2 'generalizations'>
        <Collapse <TimeElapsed 0>>
        <RenewAllIndices>
        <c-prefal
            (e.output)
            (
                (EXTERN )
                <TransformIntoRefal
                    <PredMainStep
                        <TransformEncoding ()() <prefal e.input>>
                    >
                (Comment '/*This file is generated by MSCP at '<Time>'.*/')
                (Comment '/*Elapsed time of embeddings is '<FormatOut <Dg 'emb_time'>>'.*/')
                (Comment '/*Elapsed time of generalizations is '<FormatOut <Dg 'mgu_time'>>'.*/')
                >
            )
            ('/verbose')
        >
        <Close 1><Close 2>;
}

/*Ïðåîáðàçóåò íàòóðàëüíîå ÷èñëî â ôîðìàò <÷èñëî>.<÷èñëî>.*/
FormatOut {
    s.x = <Div s.x 1000>'.'<Mod s.x 1000>;
}


Delcomm {
 = ;
(Comment e.1) e.2 = <Delcomm e.2>;
(t.other e.1) e.2 = (t.other <Delcomm e.1>)<Delcomm e.2>;
}

$ENTRY SubdirSign {
*  Windows
*    = '\\';
* Linux
    = '/';
*  Macintosh (Apple)
*    = ':' ;
}

/*
    Ôóíêöèÿ ïîëó÷åíèÿ èìåíè âõîäíîãî ôàéëà.
   [string] => [string].ref
*/
GetInputFile {
/* 0. Âûäåëÿåì ïóòü äî ôàéëà. */
    (e.path)e.1 e.2 e.3
    , <SubdirSign> : e.2
        = <GetInputFile (e.path e.1 e.2) e.3>;
/* 1. Åñëè ôàéë èìååò ðàñøèðåíèå ref, äàííîãî ôàéëà â ïàïêå çàïóñêà íåò, è ïóòü äî íåãî ïóñò, ïðîâåðÿåì åãî íàëè÷èå â ïîäïàïêå test. */
    (/* EMPTY */)e.1'.ref'
    , <ExistFile e.1'.ref'> : False
    , <ExistFile 'tests'<SubdirSign>e.1'.ref'> : True
        = ('tests'<SubdirSign>)'tests'<SubdirSign> e.1'.ref';
/* 2. Åñëè èìÿ â ïàðàìåòðàõ çàïóñêà â êîìàíäíîé ñòðîêå îòñóòñòâóåò, ôàéëîì ïî óìîë÷àíèþ ñ÷èòàåì tests\test.ref */
    (e.path) /* EMPTY */
    , <ExistFile 'tests'<SubdirSign>'test.ref'>
    : {True
        = <Prout ' The input file is tests'<SubdirSign>'test.ref'> ('tests'<SubdirSign>)'tests'<SubdirSign>'test.ref';
	False
	= 'ERR Please add the file test.ref to the subfolder '<SubdirSign>'tests.';
	};
/* 3. Åñëè èìÿ çàäàíî ñ ðàñøèðåíèåì ref -- îñòàâëÿåì åãî êàê åñòü. */
    (e.path)e.1'.ref'
	, <ExistFile e.path e.1'.ref'>
	: {True = (e.path)e.path e.1'.ref';
	False = 'ERR The input file does not exist.';
	};
/* 4. Åñëè èìÿ çàäàíî ñ äðóãèì ðàñøèðåíèåì -- âûâîäèì ñîîáùåíèå îá îøèáêå. */
    (e.path)e.1'.'e.2 = 'ERR The input file does not have the proper extension. Please use the input files with .ref extension.';
/* 5. Åñëè èìÿ çàäàíî áåç ðàñøèðåíèÿ -- ïðèïèñûâàåì ðàñøèðåíèå ref. */
    (e.path)e.1 = <GetInputFile (e.path)e.1'.ref'>;
}

/* Ôóíêöèÿ ïîëó÷åíèÿ èìåíè âûõîäíîãî ôàéëà (ôàéëà îñòàòî÷íîé ïðîãðàììû). */
GetOutputFile {
/* 1. Åñëè èìÿ â ïàðàìåòðàõ çàïóñêà â êîìàíäíîé ñòðîêå îòñóòñòâóåò, îñòàòî÷íàÿ ïðîãðàììà ïîìåùàåòñÿ â ôàéë rsd_[èìÿ âõîäíîãî ôàéëà]. */
    (e.path)(e.path e.1)  = e.path'rsd_'e.1;
/* 2. Åñëè èìÿ çàäàíî ñ ðàñøèðåíèåì ref -- îñòàâëÿåì åãî êàê åñòü. */
    (e.path)(e.1) e.2'.ref'
	, <SubdirSign> : e.SubD
	, e.2 : e.x2 e.SubD e.xx2 = e.2'.ref';
/* 2a. Åñëè ïóòü äî âûõîäíîãî ôàéëà ÿâíî íå óêàçàí -- êîïèðóåì ïóòü äëÿ âõîäíîãî ôàéëà.*/
    (e.path)(e.1) e.2'.ref'= e.path e.2'.ref';
/* 3. Åñëè èìÿ çàäàíî ñ äðóãèì ðàñøèðåíèåì -- óäàëÿåì ýòî ðàñøèðåíèå è ïðèïèñûâàåì ðàñøèðåíèå ref. */
    (e.path)(e.1)e.2'.'e.3 = <GetOutputFile (e.path)(e.1)e.2'.ref'>;
/* 4. Åñëè èìÿ çàäàíî áåç ðàñøèðåíèÿ -- ïðèïèñûâàåì ðàñøèðåíèå ref. */
    (e.path)(e.1)e.2 = <GetOutputFile (e.path)(e.1)e.2'.ref'>;
}


/*$ENTRY Go {= <Open 'w' 1 'trace_scp'><Put 1 <HomeomorphicEmb ((par e 13 )'II'(par e 269 )'II'(par e 269 )(call (Mul1 14 )(args (arg ('*'(par e 269 ))'II'(par e 269 )))))
                (par e 13 )'III'(par e 542 )'III'(par e 542 )'III'(par e 542 )(call (Mul1 15 )(args (arg ('*'(par e 542 ))'III'(par e 542 ))))>><Close 1>;
            }

/*Ôóíêöèÿ, îáíóëÿþùàÿ âñå èíäåêñû.
varl_ind - èíäåêñû ïåðåìåííûõ â ñòåêå
pari_ind - èíäåêñû ïàðàìåòðîâ òèïà i
wevali_ind - èíäåêñû ñòðîêîâûõ ïåðåìåííûõ òèïà i
time_stamp - âðåìåííûå ìåòêè âûçîâîâ ôóíêöèé (äëÿ îòíîøåíèÿ Òóð÷èíà)
emb_time - îáùåå âðåìÿ, çàòðà÷åííîå íà ïðîâåðêó âëîæåíèé
mgu_time - îáùåå âðåìÿ, çàòðà÷åííîå íà îáîáùåíèÿ
eqsolv_time - îáùåå âðåìÿ, çàòðà÷åííîå íà ðåøåíèå óðàâíåíèé â ñëîâàõ
*/
RenewAllIndices {
= <RenewIndices 'varl_ind'><RenewIndices 'time_stamp'><RenewIndices 'pare_ind'><RenewIndices 'part_ind'><RenewIndices 'pars_ind'>
<RenewIndices 'wevalt_ind'><RenewIndices 'wevale_ind'><RenewIndices 'wevals_ind'><RenewIndices 'emb_time'><RenewIndices 'mgu_time'>
<RenewIndices 'eqsolv_time'><RenewIndices 'Subtree'>;
}

ProutByStrings {
     = ;
    t.1 e.1 = <Prout t.1><Prout><ProutByStrings e.1>;
}

/*******************************  Ôóíêöèè ïåðåêîäèðîâêè **************************************/


/*Ïåðåâîä ïðåäëîæåíèé îñòàòî÷íîé ôóíêöèè èç ïðîìåæóòî÷íîãî ïðåäñòàâëåíèÿ â ïðåäñòàâëåíèå prefal*/
TransformIntoRefal {
     = ;
    (Comment e.1) e.other = (Comment e.1)<TransformIntoRefal e.other>;
    ((ENTRY) t.FunctionName e.Definitions) e.other = ((ENTRY) (Go) <TransformDefinition e.Definitions>) <TransformIntoRefal e.other>;
    ((LOCAL) (t.FunctionName t.Number) e.Definitions) e.other = ((LOCAL) (<Implode <Explode t.FunctionName><Symb t.Number>>)
        <TransformDefinition e.Definitions>)<TransformIntoRefal e.other>;
}

/*Ïåðåâîä ïðîìåæóòî÷íîãî ïðåäñòàâëåíèÿ îïðåäåëåíèÿ ôóíêöèè â ïðåäñòàâëåíèå prefal*/
TransformDefinition {
    =;
    ((e.Pars)'='(e.RightSide)) e.Other = ((<TransformExpressionToPrefal e.Pars>)'='(Expression <TransformExpressionToPrefal e.RightSide>))
                                        <TransformDefinition e.Other>;
}

/*Ïåðåâîä âûðàæåíèÿ â ïðåäñòàâëåíèå prefal*/
TransformExpressionToPrefal {
     = ;
    (Variable s.Sym t.name) e.other, <Type t.name>: 'N' = (Variable <Explode s.Sym> <Implode <Symb t.name>>)<TransformExpressionToPrefal e.other>;
    (Variable s.Sym t.name) e.other, <Type t.name>: 'D' = (Variable <Explode s.Sym> <Implode <Symb t.name>>)<TransformExpressionToPrefal e.other>;
    (Variable s.Sym t.name) e.other = (Variable <Explode s.Sym> t.name)<TransformExpressionToPrefal e.other>;
/*Çäåñü íåäîäåëêà - íóæíî ïðèïèñûâàòü òåã Word, ÷òîáû íå ïóòàòü ñèìâîëû è ìàêðîñèìâîëû*/
    s.Sym e.other = s.Sym <TransformExpressionToPrefal e.other>;
    (Bracket' 'e.1)e.2 = (Bracket <TransformExpressionToPrefal e.1>)<TransformExpressionToPrefal e.2>;
    (Call (t.fname s.number) e.arg) e.other = (Call <Implode <Explode t.fname><Symb s.number>> <TransformExpressionToPrefal e.arg>)<TransformExpressionToPrefal e.other>;
}

/*Áàçîâàÿ ôóíêöèÿ ïåðåêîäèðîâêè èç ôîðìàòà prefal âî âíóòðåííèé ôîðìàò MSCP.
((t.fname((e.LHS)e.RHS)^*)^*)((t.fname((e.LHS)e.RHS)^*)^*)e.ExpressionToTransform =>
((t.fname((e.LHS)e.RHS)^*)^*)[Stack]
*/
TransformEncoding {
/*1. Ïåðåêîäèðîâêà çàâåðøåíà. Ñ÷èòàåì, ÷òî âõîäíàÿ òî÷êà ëèøü îäíà, è îíà ïîìåùàåòñÿ â âåðøèíó ñòåêà*/
        (e.functions)(e.entrypoints) = (e.functions)(((assign (var l (0)) (e.entrypoints)) ));
/*2. Èãíîðèðóåì èíôîðìàöèþ î âíåøíèõ ôóíêöèÿõ*/
	(e.functions)(e.entrypoints)(EXTERN e.ext) e.rest  = <TransformEncoding (e.functions)(e.entrypoints) e.rest>;
/*3. Èãíîðèðóåì êîììåíòàðèè âíå îïðåäåëåíèé ôóíêöèé*/
	(e.functions)(e.entrypoints)(Comment e.ext) e.rest = <TransformEncoding (e.functions)(e.entrypoints) e.rest>;
/*4. Âõîäíóþ òî÷êó (åäèíñòâåííóþ) çàïîìèíàåì îòäåëüíî*/
	(e.functions)(e.entrypoints)((ENTRY) t.fname e.CommentBefore ((e.lhs)'=' (Expression e.rhs))e.CommentAfter) e.rest=
		<TransformEncoding (e.functions)(e.entrypoints <ConvertEntry e.rhs>) e.rest>;
/*5. Ïåðåêîäèðîâêà îïðåäåëåíèÿ ôóíêöèè*/
	(e.functions)(e.entrypoints)((LOCAL) (e.fname) e.definition) e.rest =
                                   <TransformEncoding (e.functions (e.fname (Sents <ConvertDef e.definition>)))(e.entrypoints) e.rest>;

}

/*Ôóíêöèÿ ïåðåâîäà êîäèðîâêè äëÿ ïðåäëîæåíèé â îïðåäåëåíèè ôóíêöèè èç ôîðìàòà prefal âî âíóòðåííèé ÿçûê MSCP*/
ConvertDef {
	=;
/*Êîììåíòàðèè â îïðåäåëåíèÿõ ôóíêöèé óäàëÿþòñÿ*/
	(Comment e.x) e.rest = <ConvertDef e.rest>;
/*Ëåâûå è ïðàâûå ÷àñòè ïîìåùàþòñÿ çà îäíè ñêîáêè è êàæäàÿ ïåðåêîäèðóåòñÿ*/
	((e.lhs) '=' (Expression e.rhs)) e.rest = ((<ConvertExpr e.lhs>) <ConvertExpr e.rhs>) <ConvertDef e.rest>;
}

/*Ôóíêöèÿ ïåðåâîäà êîäèðîâêè äëÿ âûðàæåíèÿ â îïðåäåëåíèè ôóíêöèè èç ôîðìàòà prefal âî âíóòðåííèé ÿçûê MSCP*/
ConvertExpr {
	=;
/*1. ïåðåêîäèðîâêà êîíñòàíò â ñåáÿ*/
	s.1 e.1 = s.1 <ConvertExpr e.1>;
/*2. ñëîâî ïåðåêîäèðóåòñÿ ïðîñòî â ñåáÿ*/
	(Word e.1)   e.2 = e.1 <ConvertExpr e.2>;
/*3. ïåðåêîäèðîâêà ñòðóêòóðíûõ ñêîáîê*/
	(Bracket e.1) e.2 = ('*'<ConvertExpr e.1>) <ConvertExpr e.2>;
/*4. ïåðåêîäèðîâêà ïåðåìåííûõ ðàçíûõ òèïîâ*/
	(Variable 's' t.name) e.2 = (var s t.name) <ConvertExpr e.2>;
	(Variable 'e' t.name) e.2 = (var e t.name) <ConvertExpr e.2>;
	(Variable 't' t.name) e.2 = (var t t.name) <ConvertExpr e.2>;
/*5. ÷èñëî ïåðåêîäèðóåòñÿ ïðîñòî â ñåáÿ*/
	(MacroDigit s.digit)  e.2 = s.digit <ConvertExpr e.2>;
/*6. ïåðåêîäèðîâêà âûçîâà ôóíêöèè*/
	(Call s.fname e.arg) e.rest = (call s.fname (args (arg <ConvertExpr e.arg>))) <ConvertExpr e.rest>;
/*7. â îñòàëüíûõ ñëó÷àÿõ - ñîîáùåíèå îá îøèáêå*/
	e.z = <Prout 'The input language contains non-basic primitives.'> <Recogn_Impossible>;
}

/*Ôóíêöèÿ ïåðåâîäà êîäèðîâêè èç ôîðìàòà prefal âî âíóòðåííèé ÿçûê MSCP äëÿ âûðàæåíèÿ, ñòîÿùåãî â âûçîâå ENTRY.
Îòëè÷àåòñÿ îò ïðåäûäóùåé òåì, ÷òî "ïåðåìåííûå", êîòîðûå â ížì óêàçàíû, ñóòü ïàðàìåòðû*/
ConvertEntry {
	(Comment e.x) e.rest = <ConvertEntry e.rest>;
	=;
	s.1 e.1 = s.1 <ConvertEntry e.1>;
	(Word e.1)    e.2 = e.1 <ConvertEntry e.2>;
	(Bracket e.1) e.2 = ('*'<ConvertEntry e.1>) <ConvertEntry e.2>;
	(Variable 's' t.name) e.2 = (par s t.name) <ConvertEntry e.2>;
	(Variable 'e' t.name) e.2 = (par e t.name) <ConvertEntry e.2>;
	(Variable 't' t.name) e.2 = (par t t.name) <ConvertEntry e.2>;
	(MacroDigit s.digit)  e.2 = s.digit <ConvertEntry e.2>;
	(Call s.fname e.arg) e.rest = (call s.fname (args (arg <ConvertEntry e.arg>))) <ConvertEntry e.rest>;
	e.z = <Prout 'The input language contains non-basic primitives.'> <Recogn_Impossible>;
}

/*
Äåêîäèðîâàíèå ðåçóëüòàòà ðàáîòû UnfoldMain ïåðåä åãî âûäà÷åé
ñèìâîë * ïîñëå îòêðûâàþùåé ñêîáêè óäàëÿåòñÿ */
/*Decode {
	= ;
	s.1 e.1 = s.1 <Decode e.1>;
	('*' e.1) e.2 = (<Decode e.1>) <Decode e.2>;
}*/
/*******************************  Çàêîí÷èëèñü ôóíêöèè ïåðåêîäèðîâêè **************************************/

/*
	Ïðîèçâîäèì äåêîìïîçèöèþ âõîäíîãî âûçîâà è çàïóñêàåì ãëàâíóþ ôóíêöèþ
	(e.Program)(((assign (var l t.n ) (e.expr)))) => (Node Finished (e.NodeData)(Children [Node]^*))
*/
PredMainStep {
(e.Program)(((assign (var l t.n )(e.expr))))=<YieldProgramGeneration
						<UnfoldMain
						(e.Program)
                                                (Node Undriven (0)
							(()()()<FormatStack <YieldDecomposition
                                                        (((assign (var l t.n )(<AssignTimeStamps e.expr>))))>>)
						)
						((0))
						(Node Undriven (0) ())
						>
                                                >;
}

/***********************************************************************************************************
* Îñíîâíîé øàã
  <UnfoldMain (e.Program)[NodeX]([PathOfX])[FullTree]> ==> [FullTree]
  [Node]::= (Node t.Status t.Name ((e.Restrictions)(e.ConfigEquations)(e.LetExpressions)(e.FullConfig)(e.Stack))
  (Children [Node]^*))
  t.Status::= Driven | Undriven | Ready | Finished | (Looped e.NodeName)|ReadyForGenCheck
  [PathOfX]:: = ((0) [NodeName]^*)
  [FullTree]::= (Node t.Status (0) (e.NodeData)(Children [Node]^*))
************************************************************************************************************/

UnfoldMain {
	/*1. Êîðíåâàÿ âåðøèíà íå èìååò ïîòîìêîâ ñ íåïðîãíàííûìè êîíôèãóðàöèÿìè*/
	t.Program (Node Finished t.RootName e.ConfNode)(t.RootName) (Node t.Status t.RootName e.Config)
		= (Node Finished t.RootName e.ConfNode);
	/*2. ïðîòèâîðå÷èå â êîðíåâîé êîíôèãóðàöèè*/
	t.Program (Node Driven (e.RootName) (e.CurrConf) (Children )) (t.RootName) (Node t.Status t.RootName e.Config)
		= Contradiction;
	/*3. ïðîòèâîðå÷èå â íåêîðíåâîé êîíôèãóðàöèè - ïåðåõîäèì ê åå ðîäèòåëþ*/
	t.Program (Node Driven t.NodeName (e.CurrConf) (Children ))(e.Path t.NodeName) t.Tree
		= <UnfoldMain t.Program <FindNode (e.Path) <DeleteNode (e.Path t.NodeName) t.Tree>>
				(e.Path)<DeleteNode (e.Path t.NodeName) t.Tree>>;
	/*4. çàâåðøåíèå âû÷èñëåíèé â íåêîðíåâîé êîíôèãóðàöèè - ïåðåõîäèì ê åå ðîäèòåëþ*/
	t.Program t.Node t.Path t.Tree,
	<GetNodeStatus t.Node> : Finished,
	<FindAncestorPath t.Path <GetNodeName t.Node>> : t.NewPath
		= <UnfoldMain t.Program <FindNode t.NewPath t.Tree>
				t.NewPath t.Tree>;
	/*5. åñëè óçåë ïðîãíàí è èìååò åäèíñòâåííûé äî÷åðíèé óçåë ñ âûòîëêíóòûì âûçîâîì, çàìåíÿåì åãî äàííûìè äàííûå óçëà
	25.12.16. Âîîáùå-òî çäåñü îí íå åäèíñòâåííûé, è ýòî íå îïòèìàëüíî: íàäî, êàê è â SCP4, äåëàòü âåòâëåíèå íèæå ïî
        ðåñòðèêöèÿì.*/
	t.Program t.Node (e.Path) t.Tree,
        <GetNodeStatus t.Node> : ReadyForGenCheck,
        <GetNodeChildren t.Node> : e.1 (e.PushChild ((Push)e.OtherConf)) e.2,
        <GetNodeRestrictions t.Node> : (e.Restrictions),
        <GetNodeStack (e.PushChild ((Push)e.OtherConf))> : t.NewStack,
        <FoldStackIntoConf t.NewStack> : e.NewFullConfig,
        <PutNodeStatus t.Node Ready> : t.Node1,
        <PutNodeStack t.Node1 t.NewStack> : t.Node2,
	<PutNodeChildren t.Node2 > : t.Node3,
        <PutNodeConfig t.Node3 (e.NewFullConfig)> : t.ProcessedNode
		=
		<UnfoldMain
			t.Program
				<PrintIfTracing t.ProcessedNode>
				(e.Path)
				<InsertNode t.ProcessedNode (e.Path)t.Tree>
		>;
        /*5à. åñëè óçåë ïðîãíàí è èìååò åäèíñòâåííûé äî÷åðíèé óçåë, ïðè÷åì òðàíçèòíûé, åãî íå îáîáùàåì
	*/
/*	t.Program
        (Node ReadyForGenCheck t.Nodename ((e.Restrictions) e.Conf)
            (Children (Node Undriven t.ChildNode ((Always) e.NewConf)))
        )
        (e.Path) t.Tree
		=
		<UnfoldMain
			t.Program
				<PrintIfTracing (Node Driven t.Nodename ((e.Restrictions) e.Conf)
                                                        (Children (Node Undriven t.ChildNode ((Always) e.NewConf))))>
				(e.Path)
				<InsertNode (Node Driven t.Nodename ((e.Restrictions) e.Conf)
                                    (Children (Node Undriven t.ChildNode ((Always) e.NewConf)))
                                    )(e.Path)t.Tree
                                >
		>;*/
	/*6. åñëè óçåë ïðîãíàí èëè îêàçàëîñü, ÷òî åãî êîíôèãóðàöèÿ ïîâòîðíà):
	a) âñòàâëÿåì ïðîãîíêó â äåðåâî ïóòåé
	è
	á) èùåì áëèæàéøèé íåïðîãíàííûé óçåë
	*/
	t.Program t.Node (e.Path) t.Tree,
        <GetNodeStatus t.Node> : Driven
		=
		<UnfoldMain
			t.Program
			<ChooseUndrivenNode
				t.Node
				(e.Path)
				<InsertNode t.Node(e.Path)t.Tree>
			>
		>;

	t.Program t.Node(e.Path) t.Tree,
        <GetNodeStatus t.Node> : (Looped e.LoopData)
		=
		<UnfoldMain
			t.Program
			<ChooseUndrivenNode
				t.Node
				(e.Path)
				<InsertNode t.Node(e.Path)t.Tree>
			>
		>;
	/*7. Ïðîâåðÿåì, èìåþòñÿ ëè êîíôèãóðàöèè, ïîâòîðÿþùèå äàííóþ*/
/*	t.Program (Node Undriven t.Name (e.Conf (e.FullConf)(e.Stack))
		)(e.Path t.Last) t.Tree
		= <UnfoldMain t.Program
                        (Node
                            <CheckNode4Equivalence
                                (e.FullConf)
                                (e.Path)
                                t.Tree
                            >
                            t.Name (e.Conf (e.FullConf)  (e.Stack))
                        )
                    (e.Path t.Last) t.Tree
                    >;*/
        t.Program t.Node (e.Path t.Last) t.Tree,
        <GetNodeStatus t.Node> : Undriven,
        <PutNodeStatus t.Node Ready> : t.ProcessedNode
		= <UnfoldMain t.Program
                        t.ProcessedNode
                    (e.Path t.Last) t.Tree
                    >;
        /*8. Åñëè óçåë òðàíçèòíûé, ìû åãî íå îáîáùàåì*/
/*	t.Program (Node ReadyForGenCheck t.Name ((Always)e.Conf (e.FullConf)(e.Stack))
		)(e.Path t.Last) t.Tree
		= <UnfoldMain t.Program
                        (Node
                            Ready
                            t.Name ((Always)e.Conf (e.FullConf)  (e.Stack))
                        )
                    (e.Path t.Last) t.Tree
                    >;
*/
	/*9. Ïðîâåðÿåì, ÿâëÿåòñÿ ëè óçåë _ïîñëå_ ïðîãîíêè êàíäèäàòîì íà îáîáùåíèå*/
	t.Program t.Node (e.Path t.Last) t.Tree,
        <GetNodeStatus t.Node> : ReadyForGenCheck,
        <GetNodeName t.Node> : t.Name,
        <GetNodeConfig t.Node> : e.FullConf,
        <GetNodeStack t.Node> : t.Stack,
        <PutNodeStatus t.Node <CheckNode4Generalization t.Name (e.FullConf)t.Stack(e.Path)t.Tree>> : t.ProcessedNode
		= <UnfoldMain t.Program
                        t.ProcessedNode
                    (e.Path t.Last) t.Tree
                    >;
	/*10à. Óçåë îáîáùàåòñÿ --- âàðèàíò îáîáùåíèÿ ñíèçó (âåðõíÿÿ êîíôèãóðàöèÿ åñòü MGU äëÿ íèæíåé ñ òî÷íîñòüþ äî ïåðåèìåíîâêè)*/
	t.Program t.Node (e.Path t.Last) t.Tree,
        <GetNodeStatus t.Node> : (Generalized t.SomeName (Looped e.LoopData)(e.GenFullConf)(e.GenStack)(e.Assignments)(e.Children)),
        <GetNodeName t.Node> : (e.Name),
        <DeleteNodeActiveData t.Node> : t.Node1,
        <PutNodeEqs t.Node1 ()> : t.Node2,
	<PutNodeStatus t.Node2 Driven> : t.Node3,
        <GenerateNewNode (e.Name 0)> : t.NewNode0,
        <PutNodeStatus t.NewNode0 (Looped e.LoopData)> : t.NewNode1,
        <PutNodeStack t.NewNode1 (e.GenStack)> : t.NewNode2,
        <PutNodeConfig t.NewNode2 (e.GenFullConf)> : t.ProcessedNewNode,
        <PutNodeChildren t.Node3 t.ProcessedNewNode e.Children> : t.Node4,
        <PutNodeLets t.Node4 (Let e.Assignments In (e.GenFullConf))> : t.ProcessedNode
		= <UnfoldMain t.Program
                    <PrintIfTracing t.ProcessedNode>
                    (e.Path t.Last) t.Tree
                >;
	/*10á. Óçåë îáîáùàåòñÿ --- îáîáùåíèå â êîíôèãóðàöèè ïðåäêà (âñå ïðåæíèå ïîòîìêè êîíôèãóðàöèè ïðåäêà óäàëÿþòñÿ)*/
	t.Program t.Node (e.Path t.Last) t.Tree,
        <GetNodeStatus t.Node> : (Generalized t.AncestorName (UpperGeneralization With (e.NewEquations))(e.GenFullConf)(e.GenStack)(e.Assignments)(e.Children)),
        t.AncestorName : (e.AncestorList),
        <FindNode (<GenPath t.AncestorName>) t.Tree> : t.AncestorNode0,
        <PutNodeEqs t.AncestorNode0 ()> : t.AncN1,
        <PutNodeLets t.AncN1 (Let e.Assignments In (e.GenFullConf))> : t.AncN2,
        <DeleteNodeActiveData t.AncN2> : t.AncN3,
        <PutNodeStatus t.AncN3 Driven> : t.AncN4,
        <GenerateNewNode (e.AncestorList 0)> : t.NewNode0,
        <PutNodeStatus t.NewNode0 Undriven> : t.NewNode1,
        <PutNodeStack t.NewNode1 (e.GenStack)> : t.NewNode2,
        <PutNodeConfig t.NewNode2 (e.GenFullConf)> : t.NewNode3,
        <PutNodeEqs t.NewNode3 (e.NewEquations)> : t.ProcessedNewNode,
        <PutNodeChildren t.AncN4 t.ProcessedNewNode e.Children> : t.ProcessedAncNode
        	=
		<UnfoldMain t.Program
                    <PrintIfTracing t.ProcessedAncNode>
                    (<GenPath t.AncestorName>) t.Tree
		>;
	/*11. Åñëè óçåë íå ïðîãíàí, çàïóñêàåì ïðîãîíêó*/
	/*Íà ñàìîì íèæíåì óðîâíå ñàìàÿ ëåâàÿ ïåðåìåííàÿ - âûçîâ: ïðîèçâîäèì ïðîãîíêó äëÿ ýòîãî âûçîâà */
	t.Program t.Node (e.Path) t.Tree,
                <GetNodeStatus t.Node> : Ready,
                <GetNodeStack t.Node> : t.Stack,
                <GetNodeName t.Node> : t.Name,
                <GetStackTop t.Stack> : (call t.fdata (args (arg e.Arg))),
                t.fdata : (t.fname t.timestamp),
                <PutNodeStatus t.Node ReadyForGenCheck> : t.Node1,
                <PutNodeChildren
			t.Node1
			<YieldDriving
				<FindFunctionDef t.Program t.fdata>
				t.fname
				(e.Arg)
				t.Name
				(<GetNodeFullConfig t.Node>)
			>
		> : t.ProcessedNode
		= <UnfoldMain t.Program
                    <PrintIfTracing t.ProcessedNode>
                    (e.Path) t.Tree
                >;

	/*12. âû÷èñëåíèÿ â óçëå çàâåðøåíû - âñòàâëÿåì äàííûé óçåë â äåðåâî ñ ïîìåòêîé Finished*/
	t.Program t.Node (e.Path) t.Tree,
            <PutNodeStatus t.Node Finished> : t.ProcessedNode
		= <UnfoldMain
			t.Program
			t.ProcessedNode
			(e.Path)
			<PrintIfTracing <InsertNode t.ProcessedNode(e.Path)t.Tree>>
		>;
}


/*Ïîèñê îïðåäåëåíèÿ ôóíêöèè, êîòîðóþ ïëàíèðóåòñÿ âûïîëíèòü
([Program])[FunctionName] => ([e.FirstPattern])([e.FirstRightHandSide])((([Pattern])[RightHandSide])^*)
*/
FindFunctionDef {
	(e.ProgramBefore (t.fname (Sents ((e.LHS)e.RHS) e.RestDefs)) e.ProgramAfter) (t.fname t.timestamp) =
		(e.LHS)(e.RHS)(e.RestDefs);
}

/*Çàïóñê ïðîöåññà ïðîãîíêè
([Pattern])([RightHandSide])([FunctionDefinition]^*) [FunctionName]
([FunctionArgument])
[NodeName] ((e.Restrictions)(e.LetExpressions)(e.ConfigEquations)(e.FullConfig)(e.Stack)) =>
[Tree]^+ (íàáîð âåðøèí - äî÷åê [NodeName])
*/
YieldDriving {
(e.LHS)(e.RHS)(e.RestDefs) t.fname (e.Config) t.NodeName ((e.Restrictions)(e.ConfigEquations)(e.FullConfig)(e.Stack))
    = <GenerateNextLevel t.NodeName (0)
				((e.Restrictions)(e.ConfigEquations)()(e.FullConfig)(e.Stack))
				(t.fname (Try e.Config)(SubsTo e.RHS)(e.RestDefs))
				<PostProcessPRTC ()()
					<ClashLeft <Putout 1 'New Clash:'><Put 1((e.ConfigEquations (Desired))()()(((e.Config) to (e.LHS))(Delayed ))('T'))><Putout 1>>
				>
			>;
}


/*Óäàëåíèå âåðøèíû èç äåðåâà ïî åå ïóòè
[path][tree]^+ =>[tree]
[path]::=([nodename]+) (ïîðÿäîê - îò êîðíÿ ê âåðøèíå, ïóòü äî êîòîðîé óêàçàí)
[tree]::=(Node [NodeStatus] [NodeName] (([restriction]^*|Always|Push) ([equation]^*)([LetExpressions]^*)([FullConfiguration])([Stack]))
(Children [tree]^*))
*/
DeleteNode {
/*1. Îò ïóòè îñòàëîñü ïðîñòî èìÿ âåðøèíû - ìû íà íóæíîì óðîâíå â äåðåâå, óäàëÿåì åå*/
	(t.NodeName) e.NodesBefore (Node t.Status t.NodeName e.Config) e.NodesAfter =
		e.NodesBefore e.NodesAfter;
/*2. Íà êàæäîì íîâîì ýòàïå èùåì ïðåäêà óäàëÿåìîé âåðøèíû, îñòàâëÿåì âñåõ åãî ñîñåäåé êàê åñòü, è ïåðåõîäèì ê åãî ïîòîìêàì*/
	(t.AncestorNodeName e.NextAncestors)
	e.NodesBefore (Node t.Status t.AncestorNodeName e.Config (Children e.Children)) e.NodesAfter
		=
		e.NodesBefore
		(Node t.Status t.AncestorNodeName e.Config (Children <DeleteNode (e.NextAncestors) e.Children>))
		e.NodesAfter;
}

/*Âñòàâêà âåðøèíû ñ îáíîâëåííûìè äàííûìè â äåðåâî
[NewNode][path][Tree]^+ =>[tree]
[path] - ïîçèöèÿ, íà êîòîðóþ âñòàâëÿåòñÿ [NewNode]. Ñ÷èòàåì, ÷òî îíà â äåðåâå [Tree] âñåãäà ñóùåñòâóåò.
*/
InsertNode {
/*1. Îò ïóòè îñòàëîñü ïðîñòî èìÿ âåðøèíû - ìû íà íóæíîì óðîâíå â äåðåâå, âñòàâëÿåì íîâûå äàííûå*/
	(Node e.NewConf)(t.NodeName) e.NodesBefore(Node t.Status t.NodeName e.Config) e.NodesAfter =
		e.NodesBefore (Node e.NewConf) e.NodesAfter;
/*2. Íà êàæäîì íîâîì ýòàïå èùåì ïðåäêà èçìåíÿåìîé âåðøèíû, îñòàâëÿåì âñåõ åãî ñîñåäåé êàê åñòü, è ïåðåõîäèì ê åãî ïîòîìêàì*/
	(Node e.NewConf)
	(t.AncestorNodeName e.NextAncestors)
	e.NodesBefore(Node t.Status t.AncestorNodeName e.Config (Children e.Children)) e.NodesAfter
		=
		e.NodesBefore
		(Node t.Status t.AncestorNodeName e.Config (Children <InsertNode (Node e.NewConf)(e.NextAncestors) e.Children>))
		e.NodesAfter;
}

/*Âûáîð äî÷åðíåãî óçëà ñ íåçàâåðøåííîé ðàçâåðòêîé.
Âûáèðàåì èç ñïèñêà äî÷åðíèõ âåðøèí äàííîé âåðøèíû òå, êîòîðûå èìåþò ñòàòóñ Driven, Undriven èëè Ready
Åñëè òàêèõ âåðøèí íåò, âñòàâëÿåì äàííóþ âåðøèíó â äåðåâî ñ ïîìåòêîé Finished
Ôîðìàò ôóíêöèè
[ParentNode]([ChildNode]^*)[path][tree]=>[Node][path][tree]
*/
ChooseSuccessorNode {
/*1. Ó äàííîé âåðøèíû íåò äî÷åðíèõ âåðøèí, â êîòîðûõ íå äîäåëàíà ðàçâåðòêà -> âåðøèíà ïîìå÷àåòñÿ êàê Finished*/
	t.Node ()(e.Path)(e.Tree),
	<PutNodeStatus t.Node Finished> : t.Node1,
	<PutNodeChildren t.Node1> : t.Node2,
	<PutNodeLets t.Node2 (Subtree <FreshIndex 'Subtree'>)> : t.Node3,
	<DeleteNodeActiveData t.Node3> : t.ProcessedNode =
		<Collapse <Br 'Subtree'<Symb <CurrentIndex 'Subtree'>>'='t.Node1>>
		t.ProcessedNode(e.Path)<InsertNode t.ProcessedNode(e.Path)(e.Tree)>;
/*2. Î÷åðåäíîé äî÷åðíèé óçåë èìååò ñòàòóñ çàâåðøåííîãî (èëè çàöèêëåííîãî). Ðàññìàòðèâàåì äðóãèå*/
	t.Node (t.ChildNode e.OtherChildren)(e.Path)(e.Tree),
	<CheckAlter <GetNodeStatus t.ChildNode> EITHER Finished (Looped)> : True =
		<ChooseSuccessorNode t.Node (e.OtherChildren)(e.Path)(e.Tree)>;
/*3. Íàøåëñÿ èñêîìûé äî÷åðíèé óçåë - âîçâðàùàåì åãî è ïóòü äî íåãî*/
	t.Node (t.ChildNode e.OtherChildren)(e.Path)(e.Tree),
	<GetNodeName t.ChildNode> : t.ChildName
	=
		t.ChildNode <ProlongPath (e.Path) t.ChildName>(e.Tree);
}

CheckAlter {
	(t.x e.x) EITHER e.1 (t.x) e.2 = True;
	t.x EITHER e.1 t.x e.2 = True;
	t.x EITHER e.1 = False;
}

IsRoot {
	t.Node,
	<GetNodeName t.Node> : (t.Single) = True;
	t.Node = False;
}


/*Âûáîð áëèæàéøåãî ñîñåäà ñî ñòàòóñîì íåçàâåðøåííîé ïðîãîíêè (åñëè òàêîé ñîñåä åñòü)
Ôîðìàò ôóíêöèè
(Node e.Node)(e.Path)(e.Tree)=>[nodeData][path][tree]
*/
ChooseUndrivenNode {
/*1. íàøëàñü âåðøèíà, íà êîòîðîé íå çàïóñêàëàñü ïðîãîíêà è ïðîâåðêà íà ïîâòîðíîñòü ñîñòîÿíèÿ - âîçâðàùàåì åå*/
	t.Node t.Path t.Tree,
	<CheckAlter <GetNodeStatus t.Node> EITHER Undriven Ready> : True =
		t.Node t.Path t.Tree;
/*2. Àëãîðèòì äîøžë äî êîðíÿ äåðåâà è ïîìåòèë åãî êàê Finished. Âîçâðàùàåì êîðåíü*/
	t.Node t.Path t.Tree,
	<IsRoot t.Node> : True,
	<GetNodeStatus t.Node> : Finished
		= t.Node t.Path t.Tree;
/*4. Åñëè âåðøèíà èìååò ñòàòóñ Finished, è ýòî íå êîðåíü, ïðîäîëæàåì ïîèñê îò åå ðîäèòåëÿ*/
	t.Node t.Path t.Tree,
	<CheckAlter <GetNodeStatus t.Node> EITHER Finished (Looped)> : True,
	<ShortenPath t.Path> : t.NewPath
		= <ChooseUndrivenNode <FindNode t.NewPath t.Tree>t.NewPath t.Tree>;
/*6. Åñëè âåðøèíà èìååò ñòàòóñ Driven, âûáèðàåì åå äî÷êó ñî ñòàòóñîì Driven, Undriven èëè Ready è ïðîäîëæàåì ïîèñê îò íåå
åñëè æå òàêèõ äî÷åê íåò, òî ýòà âåðøèíà ïîëó÷àåò ñòàòóñ Finished*/
	t.Node t.Path t.Tree,
	<GetNodeStatus t.Node> : Driven,
	<GetNodeChildren t.Node> : e.Children =
		<ChooseUndrivenNode <ChooseSuccessorNode t.Node (e.Children)t.Path t.Tree>>;
}

/*Èçâåñòíî èìÿ âåðøèíû-ïðåäêà è ïóòü îò êîðíÿ äî åå ïîòîìêà. Ïîñòðîèòü ïóòü äî âåðøèíû ïðåäêà
([path])t.NodeName => ([path])
*/
FindAncestorPath {
    (e.PathBefore t.NodeName e.PathAfter)t.NodeName = (e.PathBefore);
}

FindNodePath {
    (e.PathBefore t.NodeName e.PathAfter)t.NodeName = (e.PathBefore t.NodeName);
}

ProlongPath {
	(e.PathBefore) t.NodeName = (e.PathBefore t.NodeName);
}

ShortenPath {
	(e.PathBefore t.NodeName) = (e.PathBefore);
}

/*Äëÿ âûõîäà ïî íåâîçìîæíîìó îòîæäåñòâëåíèþ*/
Recogn_Impossible {
aaa = ;
}

/*Äëÿ òðàññèðîâùèêà*/
AAA {
e.1 = e.1;
}

/*Äëÿ òðàññèðîâùèêà*/
PrintIfTracing {
*	e.1 = e.1;
	e.1 = <Put 1 e.1>;
}