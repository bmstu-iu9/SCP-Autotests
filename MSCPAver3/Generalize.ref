/*
Модуль функций обобщения и вложения.

Доступные из модуля функции

CheckNode4Equivalence - проверка на вложения. Формат:
(Expression)[Path][Tree] => Ready | (Looped [NodeName] (assign (par e.par)((par e.newpar)))^*)
FoldStackIntoConf - извлечение полной конфигурации из стековой. Формат:
((assign (var l t.varname)(e.Val))^+)^+ => [Expression]
CheckNode4Generalization - проверка на обобщаемость (и построение обобщения, если оно существует). Формат:
[CurrentNodeName]([CurrentConfiguration])([CurrentStack])([Path])[Tree]
=>
Driven | (Generalized [CurrentNodeName] (Looped [AncestorNodeName]) ([Configuration])([Stack])
(Children ([NodeName] Undriven (([Eqs])([Restrs])([Config])([Stack])))^*))
*/

/*из basics.ref*/
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, FindTerm, RenewIndices, FreshIndex, CurrentIndex,MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/*из basics.ref*/
$EXTERN Substitute,FindNode,CompareCalls,Collapse,AddTime;
/*из drive.ref*/
$EXTERN FormatStack;
/*из stack.ref*/
$EXTERN YieldDecomposition;
/*из formats.ref*/
$EXTERN IsFreeExpression;
/*из residual.ref*/
$EXTERN ConvertPrefal;
/*из access_MSCP.ref*/
$EXTERN GetNodeConfig, GetNodeStack, GetNodeLets;

/*
$ENTRY Go {
     = <MGUAssoc ((par e <MyZero>))((assign (par e <MyZero>) (ToUnify ('ABC')('BBA'))))()>};*/
     

/*для трассировщика*/
A {e.1 = e.1;}

/*Проверка, повторяет ли конфигурация в узле конфигурацию какого-либо предка этого узла
Если повторяет, узел помечается как зацикленный
Не повторяет - как готовый к проверке на обобщение
Вход
(Expression)[Path][Tree]
Выход
Ready | (Looped [NodeName] [Assignments])*/
$ENTRY CheckNode4Equivalence {
/*1. Проверили всех предков*/
        (e.Data)()t.Tree = Ready;
/*2. Нашли эквивалентный по конфигурации узел предка*/
	(e.Data)(e.Path t.NodeName)t.Tree,  
            <IfEquivalentConf ()(e.Data)<GetFullConf <FindNode (e.Path t.NodeName) t.Tree>>>:(e.subs) = (Looped t.NodeName e.subs);
/*3. Очередной узел не является эквивалентным - проверяем следующего предка по пути к корню*/
        (e.Data)(e.Path t.NodeName)t.Tree = <CheckNode4Equivalence (e.Data)(e.Path)t.Tree>;
}

/*Функция формата: Извлечение из узла конфигурации его терма 
Вход
(Node [NodeStatus] [NodeName] (([Restrictions])([Equations])([NegativeInfo])(Configuration)[Stack][Children]))
Выход
(Configuration)
*/
GetFullConf {
/*1. Извлекаем полную конфигурацию терма, если он не есть let-расщепление*/
    t.Node, <GetNodeLets t.Node> : (), <GetNodeConfig t.Node> : e.FullConf = (e.FullConf);
/*2. Если узел содержит let-расщепление, его не проверяем*/
    t.Node = False;
}

/*Свертка стека в единую конфигурацию, без учета внешних объектных термов, не
вовлеченных ни в один вызов функции

((assign (var l t.varname)(e.Val))^+)^+ => [ExpressionWithCalls]
*/
$ENTRY FoldStackIntoConf {
/*1. На самом верхнем уровне удаляем все объектные термы*/
    (((assign (var l e.varname) (e.Val)))) = <DeleteObjectives e.Val>;
/*2. Исчерпали переменные уровня -> переходим к следующему*/
    (()(e.NextLevel)e.UpperLevels) =
        <FoldStackIntoConf ((e.NextLevel)e.UpperLevels)>;
/*3. Подставляем значение стековой переменной вместо ее самой в верхний уровень*/
    (((assign (var l e.varname) (e.Val))e.ThisLevel)(e.NextLevel)e.UpperLevels)    =
        <FoldStackIntoConf ((e.ThisLevel)(<Substitute ((assign (var l e.varname) (e.Val)))e.NextLevel>)e.UpperLevels)>;
}

/*Удаление объектных термов с внешнего уровня
[Expression] => {(call e.call)|(par e t.parname)}^*
*/
DeleteObjectives {
    e.Val = e.Val;
/*    (call e.call)e.Val = (call e.call) <DeleteObjectives e.Val>;
    ('*'e.Val1)e.Val2 = <DeleteObjectives e.Val1><DeleteObjectives e.Val2>;
    s.1 e.Val = <DeleteObjectives e.Val>;
    (par e e.pardata) e.Val = (par e e.pardata) <DeleteObjectives e.Val>;
    (par e.pardata) e.Val = <DeleteObjectives e.Val>;*/
}

/*Проверка двух конфигураций на совпадение по модулю имен параметров
([Expression])([Expression]|False)=>([ParAssignment]^*)|False*/
IfEquivalentConf {
/*1. Завершена успешно*/
    (e.subst)()() = <IfCorrectSubs e.subst>;
/*2. параметры равных типов считаются эквивалентными*/
    (e.subst)((par s.type e.x)e.Conf1)((par s.type e.y)e.Conf2) = 
                        <IfEquivalentConf 
				(e.subst (assign (par s.type e.x)((par s.type e.y))))
				(e.Conf1)(e.Conf2)
			>;
/*3. равные термы эквиваленты*/
    (e.subst)(t.1 e.Conf1)(t.1 e.Conf2) = 
                        <IfEquivalentConf (e.subst)(e.Conf1)(e.Conf2)>;
/*4. сопоставление друг другу выражений со скобками успешно, если части выражений, отделенные скобками, эквивалентны
Через LogAnd --- поскольку нам важно, где именно стоят скобки.
Т.е. ('A')'B' не эквивалентно ('AB'), из-за положения скобок
*/
    (e.subst)(('*' e.Conf11) e.Conf12)(('*' e.Conf21) e.Conf22),
    <IfEquivalentConf (e.subst)(e.Conf11)(e.Conf21)> : (e.newSubst) = 
                        <IfEquivalentConf (e.newSubst)(e.Conf12)(e.Conf22)>;
/*5. эквивалентность вызовов = эквивалентность аргументов и совпадение имен функций*/
    (e.subst)((call t.fname1 (args (arg e.Conf1Arg))) e.Conf1)((call t.fname2 (args (arg e.Conf2Arg))) e.Conf2),
    <CompareCalls t.fname1 t.fname2> : 'T',
    <IfEquivalentConf (e.subst)(e.Conf1Arg)(e.Conf2Arg)> : (e.newSubst) =
                        <IfEquivalentConf (e.newSubst)(e.Conf1)(e.Conf2)>;
/*6. иначе эквивалентности нет*/
    (e.subst)(e.1) e.2 = False;
}

/*Удаление повторных назначений и выход в противоречие, если повторным
назначаются неповторные.*/
IfCorrectSubs {
	e.1 t.1 e.2 t.1 e.3 = <IfCorrectSubs e.1 t.1 e.2 e.3>;
	e.1 (assign t.data t.val) e.2 (assign t.data t.otherval) e.3 =
		False;
	e.Z = (e.Z);
}

/*---------------------------------------------------------------------------------
                                  ФУНКЦИИ ВЛОЖЕНИЯ
-----------------------------------------------------------------------------------*/

/*Вход 
[CurrentNodeName]([CurrentConfiguration])([CurrentStack])([Path])[Tree]
Выход
Driven | (Generalized [CurrentNodeName] (Looped [AncestorNodeName]) ([Configuration])([Stack])
(Children ([NodeName] Undriven (([Eqs])([Restrs])([Config])([Stack])))^*))
Сама конфигурация, являющаяся MGU, в список Children не входит
*/
$ENTRY CheckNode4Generalization {
/*1. Дошли до корня, и кандидатов на обобщение нет -> узел прогнан*/
	t.SuccName (e.FullConf)(e.Stack)()t.Tree = Driven;
/*2. Проверяем наличие вложения в очередной узел предка. Если оно есть, запускаем процесс обобщения*/
	t.SuccName (e.FullConf)(e.Stack)(e.Path t.NodeName)t.Tree,
                                    <Collapse <TimeElapsed 0>><EmbeddingConfs 
                                        <Putout 1 'Trying to embed: '>( <GetFullConfPlusStack <FindNode (e.Path t.NodeName) t.Tree>>)
                                                ((e.FullConf)(e.Stack))
                                    ><Collapse <AddTime ('emb_time') <TimeElapsed>>>:s.1'T' = <Putout 1 'Embedding is successful.'>
                                                            <YieldGeneralization (Depth s.1) t.SuccName t.NodeName
                                                                    <GetFullConfPlusStack
                                                                        <FindNode (e.Path t.NodeName) t.Tree>
                                                                    ><Collapse<TimeElapsed 0>>        
                                                                    (e.FullConf)(e.Stack)
                                                            ><AddTime ('mgu_time')<TimeElapsed>>;
/*3. В противном случае осуществляем проверку на вложение очередной конфигурации предка*/
    	t.SuccName (e.FullConf)(e.Stack)(e.Path t.NodeName)t.Tree =
                <CheckNode4Generalization t.SuccName (e.FullConf)(e.Stack)(e.Path)t.Tree>;
}

/*Выделение из конфигурации узла стека и полного выражения
[Node] => ([Expression])[Stack]
*/
GetFullConfPlusStack {
        t.Node, <GetNodeConfig t.Node> : e.FullConf, <GetNodeStack t.Node> : t.Stack =
                (e.FullConf)t.Stack;
}

/*Функция-формат для запуска обобщения
t.NameOfTheLowerNode t.NameOfTheUpperNode ([UpperConfigurationExpr])([LowerConfigurationExpr])
 =>
*/
YieldGeneralization {
/*    (Depth s.1) t.SuccessorName t.UpperNodeName (e.UpperConf)(e.UpperStack)(e.LowerConf)(e.LowerStack) = 
                <AnalyzeMGUResults t.SuccessorName t.UpperNodeName (e.UpperConf) 
                    <MGUAssoc 
                            ((par e <FreshIndex 'pare_ind'>))
                            ((assign (par e <CurrentIndex 'pare_ind'>)
                                (ToUnify (e.UpperConf)(e.LowerConf))
                            ))
                    >
                >;*/
   (Depth s.1) t.SuccessorName t.UpperNodeName (e.UpperConf)(e.UpperStack)(e.LowerConf)(e.LowerStack) = 
                <AnalyzeMGUResults t.SuccessorName t.UpperNodeName (e.UpperConf) 
                    <Putout 1 'Depth is 's.1>
                    <MergeFreeParameters 
                        <FormatUnification 
                            <IfEquivalentConf ()(e.UpperConf)(e.LowerConf)>
                            <ReplaceStackLevelWithNewPar (s.1)(e.UpperStack)> 
                            <ReplaceStackLevelWithNewPar (s.1)(e.LowerStack)>
                        >
                    >
                >;
}

/*(e.Pattern)(e.MGUs) => (e.Pattern)(e.MGUs)*/
MergeFreeParameters {
    /*e.1 = e.1;*/
    (e.Pattern)(e.MGUs) = <SubstituteMergedPars (e.Pattern)(e.MGUs)()<SortFreeSeq (e.MGUs)<FindFreeSeq e.Pattern>>>;
}

/*e.ParameterizedExpression => ((par e t.name1)(par e t.name2))^* */
FindFreeSeq {
    e.1 (par e t.name1)(par e t.name2) e.2 =
        ((par e t.name1)(par e t.name2)) 
        <FindFreeSeq e.1>
        <FindFreeSeq (par e t.name2) e.2>;
    e.1 (call t.fname (args (arg e.arg))) e.2 = 
        <FindFreeSeq e.1><FindFreeSeq e.arg><FindFreeSeq e.2>;
    e.1 ('*' e.inbr) e.2 = 
        <FindFreeSeq e.inbr><FindFreeSeq e.2>;
    e.Z = ;
}

/*Дан список пар открытых параметров, стоящих рядом. Перевести их в формат, входной для SubstituteMergedPars
(e.MGUs) ((par e t.name1)(par e t.name2))^* => (ToMerge (par e t.name1)(par e t.name2))^* */
SortFreeSeq {
    (e.MGUs) = ;
    (e.MGUs)e.1 t.1 e.2 t.1 e.3 = <SortFreeSeq (e.MGUs) e.1 t.1 e.2 e.3>;
/*    (e.MGUs)(t.par1 t.par2) e.triples,
    e.MGUs : e.1 (assign t.par1 e.data) e.2,
    e.MGUs : e.1 (assign t.par3 e.data) e.2 = <SortFreeSeq (e.MGUs) e.triples>;
    (e.MGUs)(t.par1 t.par2 t.par3) e.triples,
    e.MGUs : e.1 (assign t.par2 e.data) e.2 = <SortFreeSeq (e.MGUs) e.triples>;*/
    (e.MGUs)(t.par1 t.par2) e.pairs = (ToMerge t.par1 t.par2)<SortFreeSeq (e.MGUs) e.pairs>;
    (e.MGUs) t.triple e.triples = <SortFreeSeq (e.MGUs)e.triples>;
}

/*Удаление тех подстановок в обобщении, которые не встречаются в структуре.
([Expression])([Assignment]^*) => ([Expression])([Assignment]^*)
*/
DeleteNonInfMGUs {
(e.Pattern)(e.1 (assign t.par e.data) e.2),
    <IsInStructure t.par e.Pattern> : 'F'
    =
    <DeleteNonInfMGUs (e.Pattern)(e.1 e.2)>;
    e.Z = e.Z;
}

/*Дан список пар е-параметров, стоящих рядом и нуждающихся в слиянии. (после обобщения)
Построить это слияние.
(e.Pattern)(e.MGUs)(e.Equations)(ToMerge (par e s.Name1)(par e s.Name2))^* => (e.Pattern)(e.MGUs)(e.Equations)
*/
SubstituteMergedPars {
    (e.Pattern)(e.MGUs)(e.Equations) = <DeleteNonInfMGUs (e.Pattern)(e.MGUs)>(e.Equations);
    (e.Pattern)(e.MGUs)(e.Equations)e.1 t.1 e.2 t.1 e.3 = <SubstituteMergedPars (e.Pattern)(e.MGUs)(e.Equations) e.1 t.1 e.2 e.3>;
    (e.Pattern)(e.MGUs)(e.Equations)(ToMerge t.par1 t.par2) e.ToMerge,
    <FindMGU t.par1 e.MGUs> : (assign t.par1 (e.Val11)(e.Val12)),
    <FindMGU t.par2 e.MGUs> : (assign t.par2 (e.Val21)(e.Val22)),
    <FreshIndex 'pare_ind'> : t.newind
     = 
        <SubstituteMergedPars 
            (<SubstituteOnCond (t.par1)()((assign t.par1 ((par e t.newind)))(assign t.par2 ())) e.Pattern>)
            (e.MGUs (assign (par e t.newind) (e.Val11 e.Val21)(e.Val12 e.Val22)))
            (e.Equations (AreEqual (('F')(par e t.newind))(('F')t.par1 t.par2)))            
            e.ToMerge
        >;
 /*   (e.Pattern)(e.MGUs)(ToMerge (1) t.par1 t.par2) e.ToMerge,
    e.MGUs : e.1 (assign t.par2 (e.val1)(e.val2)) e.2
     = 
        <SubstituteMergedPars 
            (<SubstituteOnCond ()(t.par2)((assign t.par1 ())) e.Pattern>)
            (e.1 (assign t.par2 (t.par1 e.val1)(t.par1 e.val2)) e.2) 
            e.ToMerge
        >;*/
}

/*Подстановка при условии определенного соседства. Имеется пара назначений и она подставляется в выражение,
если и только если переменные в этом выражении, на которых есть назначения, встречаются в нём рядом и в том же порядке.
*/
SubstituteOnCond {
    (e.Before)(e.After)(e.Subst) = ;
    (e.Before)(e.After)(e.Subst) ('*'e.1)e.2,
    <SubstituteOnCond (e.Before)(e.After)(e.Subst)e.1> : e.InBr =
        ('*'e.InBr)<SubstituteOnCond (e.Before)(e.After)(e.Subst)e.2>;
    (e.Before)(e.After)(e.Subst) (call t.fname (args (arg e.1)))e.2,
      <SubstituteOnCond (e.Before)(e.After)(e.Subst)e.1> : e.Arg =
        (call t.fname (args (arg e.Arg)))<SubstituteOnCond (e.Before)(e.After)(e.Subst)e.2>;
    (t.pred)(e.After)((assign t.pred (e.Val1)) (assign t.par (e.Val2))) t.pred t.par e.1 =
        e.Val1 e.Val2 <SubstituteOnCond (t.pred)(e.After)((assign t.pred (e.Val1)) (assign t.par (e.Val2))) e.1>;
/*    (e.Before)(t.post)((assign t.par (e.Val))) t.par t.post e.1 =
        e.Val t.post <SubstituteOnCond (e.Before)(t.post)((assign t.par (e.Val))) e.1>; */
    (e.Before)(e.After)(e.Subst) t.1 e.1 =
        t.1 <SubstituteOnCond (e.Before)(e.After)(e.Subst) e.1>;
}

/*Замена стековой переменной свежим параметром.
(s.Depth)(e.Stack)=>{(assign t.par (e.LowerExpr))|(NOTHING)}(e.OuterExpr)
e.LowerExpr --- выражение, являющееся сверткой части стека, присвоенной параметру.
e.OuterExpr --- свертка стека, лежащего ниже той части, которая была свернута в параметр. Теперь она содержит вхождение этого нового параметра.
*/
ReplaceStackLevelWithNewPar {
    (0)(((assign (var l t.name)(e.Val))e.LowerLevel)) = (NOTHING)(e.Val);
    (0)((e.LowerLevel)((assign t.val (e.TopLevel)))) = 
        (NOTHING)(<Substitute (e.LowerLevel) e.TopLevel>);
    (0)((e.LowerLevel)((assign (var l t.name)(e.Val)) e.UpperLevel)(e.GrUpperLevel)e.OtherStack),
    <FreshIndex 'pare_ind'> : t.newparname,
    <Substitute (e.LowerLevel) e.Val> : e.NewVal = 
        (assign (par e t.newparname)(e.NewVal))
        (<FoldStackIntoConf ((e.UpperLevel)(<Substitute ((assign (var l t.name)((par e t.newparname)))) e.GrUpperLevel>)e.OtherStack)>);
    (s.x)((e.LowerLevel)(e.UpperLevel)e.OtherStack) =
        <ReplaceStackLevelWithNewPar (<Sub s.x 1>)((<Substitute (e.LowerLevel)e.UpperLevel>)e.OtherStack)>;
}

/*Функция, вызывающая функцию обобщения по результатам анализа и разбивки стека по отношению Турчина.*/
FormatUnification {
    t.EquivData (NOTHING)(e.UpperConf)(NOTHING)(e.LowerConf) =
        <MGUAssoc ((par e <FreshIndex 'pare_ind'>))
                            ((assign (par e <CurrentIndex 'pare_ind'>)
                                (ToUnify (e.UpperConf)(e.LowerConf))
                            ))()>;
    t.EquivData (NOTHING)(e.Bottom1)(assign t.parname2 t.STop2)(e.Bottom2) = 
            <MGUAssoc ((par e <FreshIndex 'pare_ind'>))
                            ((assign (par e <CurrentIndex 'pare_ind'>)
                                (ToUnify (e.Bottom1)(<Substitute ((assign t.parname2 t.STop2)) e.Bottom2>))
                            ))()>;
    (e.Asgs) (e.Top1)(e.Bottom1)(e.Top2)(e.Bottom2) =
        <MGUAssoc ((par e <FreshIndex 'pare_ind'>))
                            ((assign (par e <CurrentIndex 'pare_ind'>)
                                (ToUnify (<Substitute ((e.Top1)) e.Bottom1>)(<Substitute ((e.Top2)) e.Bottom2>))
                            ))()>;
 
    False (assign t.parname1 t.STop1)(e.Bottom1)(assign t.parname2 t.STop2)(e.Bottom2),
    <FreshIndex 'pare_ind'> : t.BottomPar,
    <MGUAssoc ((par e t.BottomPar))
    ((assign (par e t.BottomPar)
        (ToUnify (e.Bottom1)(e.Bottom2))))()> : (e.Pattern)(e.MGUs) = 
            (e.Pattern)(<Substitute ((assign t.parname1 t.STop1)(assign t.parname2 t.STop2))e.MGUs>);
}

/*Смотрим результат построения обобщения: обобщение сверху или снизу?
t.SuccessorName t.UpperNodeName (e.UpperConf)(e.Pattern)(e.MGUs) => 
(Generalized t.GenNodeName (UpperGeneralization | Looped t.AncestorNodeName) ([Configuration])[Stack] (Children [Node]^*))
*/
AnalyzeMGUResults {
/*0. Обобщение тривиально*/
    t.SuccessorName t.UpperNodeName (e.UpperConf)((par e t.name))(e.MGUs)(e.EquationsFromMerging) = Driven;

/*1. Обобщение снизу*/
    t.SuccessorName t.UpperNodeName (e.UpperConf)(e.Pattern)(e.MGUs)(e.EquationsFromMerging),
        <IfEquivalentConf ()(e.UpperConf)(e.Pattern)> : (e.Subs),
	<DeleteTrivialSubs (<SplitMGUs 1 e.MGUs>)(e.Subs)e.Pattern> : (e.CheckedMGUs)(e.CheckedSubs)e.CheckedPattern =
                    <Putout 2 'Generalized downwards: 't.SuccessorName' and 't.UpperNodeName' with upper config'>
                    <Putout 2 <ConvertPrefal e.UpperConf>>
                    <Putout 2>
                    <Putout 2 'Generalized Pattern: '>
                    <Putout 2 <ConvertPrefal e.CheckedPattern>>
                    <Putout 2 'Generalized MGUs: 'e.CheckedMGUs>
                    <Putout 2 'Generalized Equations: 'e.EquationsFromMerging>
                    <Putout 2>
                    <Putout 2 '*****************************************************************'>
                    <Putout 2>
                    (Generalized t.SuccessorName (Looped To t.UpperNodeName With e.CheckedSubs) <ExtractStackAndConf e.CheckedPattern>
                    <GatherChildrenInfo  () () 
                        <GenerateChildrenOfGenNode (e.EquationsFromMerging)t.SuccessorName 1
                             e.CheckedMGUs
                        >
                    >
                    );
/*2. обобщение сверху*/
    t.SuccessorName t.UpperNodeName (e.UpperConf)(e.Pattern)(e.MGUs)(e.EquationsFromMerging), 
	<DeleteTrivialSubs (<SplitMGUs 0 e.MGUs>)()e.Pattern> : (e.CheckedMGUs)()e.CheckedPattern,
        <GenerateNewEquations e.MGUs> : e.NewEquations =
                    <Putout 2 'Generalized upwards: 't.SuccessorName' and 't.UpperNodeName' with upper config'>
                    <Putout 2 <ConvertPrefal e.UpperConf>>
                    <Putout 2>
                    <Putout 2 'Generalized Pattern: '>
                    <Putout 2 <ConvertPrefal e.CheckedPattern>>
                    <Putout 2 'Generalized MGUs: 'e.CheckedMGUs>
                    <Putout 2 'Generalized Equations: 'e.EquationsFromMerging e.NewEquations>
                    <Putout 2>
                    <Putout 2 '*****************************************************************'>
                    <Putout 2>
                    (Generalized t.UpperNodeName (UpperGeneralization With (e.EquationsFromMerging e.NewEquations)) <ExtractStackAndConf e.CheckedPattern>
                    <GatherChildrenInfo  () () 
                        <GenerateChildrenOfGenNode (e.EquationsFromMerging e.NewEquations) t.UpperNodeName 1
                             e.CheckedMGUs
                        >
                    >
                    );
}

/*(assign (e.pardata)(e.Val1)(e.Val2))^* => (AreEqual (('T') e.1)(('T') e.2))*/
GenerateNewEquations {
    e.MGUs1 (assign (par e t.name)()(s.Sym))e.MGUs2 =
            (AreEqual (('T')(par e t.name) s.Sym)(('T')s.Sym(par e t.name))) <GenerateNewEquations e.MGUs1 e.MGUs2>;
/*16.12.16. Добавлено 2 правила*/ 
 e.MGUs1 (assign (par e t.name)()((par s t.name2)))e.MGUs2,
    <IsInStructure (par s t.name2) e.MGUs1 e.MGUs2> : 'T' =
            (AreEqual (('T')(par e t.name) (par s t.name2))(('T')(par s t.name2)(par e t.name))) <GenerateNewEquations e.MGUs1 e.MGUs2>;
    e.MGUs1 (assign (par e t.name)()((par t t.name2)))e.MGUs2,
    <IsInStructure (par t t.name2) e.MGUs1 e.MGUs2> : 'T' =
            (AreEqual (('T')(par e t.name) (par t t.name2))(('T')(par t t.name2)(par e t.name))) <GenerateNewEquations e.MGUs1 e.MGUs2>;
    e.MGUs1 (assign (par t t.name)(s.Sym1)(s.Sym2))e.MGUs2 =
            (AreEqual (('T')(weval e <FreshIndex 'wevale_ind'>)(par t t.name)(weval e <FreshIndex 'wevale_ind'>))(('T')s.Sym1 s.Sym2)) <GenerateNewEquations e.MGUs1 e.MGUs2>;
    e.MGU = ;
}

/*Проверка, входит ли параметр в выражение.
(par e.pardata)[Expression] => s.Log*/
IsInStructure {
t.par e.1 t.par e.2 = 'T';
t.par e.1 (assign t.par1 (e.val1)) e.2 = <IsInStructure t.par e.1 t.par1 e.val1 e.2>;
t.par e.1 (AreEqual ((s.Log)(e.MSet1)(e.Val1))((s.Log2)(e.MSet2)(e.Val2))) e.2 = 
    <IsInStructure t.par e.1 e.Val1 e.Val2 e.2>;
t.par e.1 (AreEqual ((s.Log) e.Val1)((s.Log) e.Val2)) e.2 = <IsInStructure t.par e.1 e.Val1 e.Val2 e.2>;
t.par e.1 ('*' e.3) e.2 = <IsInStructure t.par e.1 e.3 e.2>;
t.par e.1 (call t.fname (args (arg e.Arg))) e.2 = <IsInStructure t.par e.1 e.Arg e.2>;
t.par e.Z = 'F';
}

/*Пока заглушка.*/
DeleteTrivialSubs {
/*	(e.subs1 (assign (par t.type t.newname)((par t.type t.oldname))) e.subs2)(e.Asgnts) e.Pattern = 
		<DeleteTrivialSubs 
			(e.subs1 e.subs2)
			(<Substitute ((assign (par t.type t.newname)((par t.type t.oldname)))) e.Asgnts>)
			<Substitute ((assign (par t.type t.newname)((par t.type t.oldname)))) e.Pattern>
		>;*/
	(e.subs) (e.asgnts)e.Pattern = (e.subs)(e.asgnts) e.Pattern;
}

/*Куски, обобщенные до е-выражений, выделяются в дочерние узлы (Форматирующая функция типа Zip)
([NewAssignment]^*)([Node]^*)([assignment][Node])^* =>([NewAssignment]^*)([Node]^*)
*/
GatherChildrenInfo {
    (e.assignments)(e.children) = (e.assignments)(e.children);
    (e.assignments)(e.children)((assign (par e.data)t.Val)(Node t.Status t.Name e.NodeData))e.others
     = <GatherChildrenInfo 
         (e.assignments (t.Name(assign (par e.data) t.Val)))
         (e.children (Node t.Status t.Name e.NodeData))
         e.others
        >;
}

/**/
GenerateChildrenOfGenNode {
/*1. Все дети по let порождены*/
	(e.NewEquations) t.UpperNodeName t.Counter =;
/*2. Очередной дочерний узел порождается: в нем нет сужений, let-выражений, есть только стек и обшая конфигурация*/
	(e.NewEquations) (e.UpperNodeName) t.Counter (assign (par e.pardata)(e.Val))e.Others =
            <CheckForCalls
                ((assign (par e.pardata) (e.Val))
                (Node Undriven (e.UpperNodeName t.Counter)(()(e.NewEquations)((par e.pardata))<ExtractStackAndConf e.Val>)))
            >
            <GenerateChildrenOfGenNode (e.NewEquations)(e.UpperNodeName) <MyInc t.Counter> e.Others>;
}

/*Проверка, не пуст ли стек у вновь порожденного узла*/
CheckForCalls {
/*1. Стек пуст => неразложенная конфигурация является финальной конфигурацией*/
 /*   ((assign e.assignment)(Node e.Node (e.Data()(e.Stack)))) = ((assign e.assignment));*/
/*2. Стек непуст => оставляем все как есть*/
    e.Z = e.Z;
}

/*дано выражение. Построить стек, соответствующий этому выражению, и это же выражение без внешних объектных термов.
[Expression] => ([Expression])[Stack]
*/
ExtractStackAndConf {
    e.Value = <FormatStack <YieldDecomposition(((assign (var l (0))(e.Value))))>>;
}

/*Расщепление подстановок в обобщении.
s.Flag (assign t.Name ([FirstExpr])([SecondExpr]))^* => (assign t.Name ([Expr]))^*
s.Flag=0 => выбираем первое значение в подстановке
s.Flag=1 => выбираем второе
*/
SplitMGUs {
    s.Flag =;
    0 (assign (e.pardata)(e.Val1)(e.Val2)) e.MGUs = (assign (e.pardata)(e.Val1))<SplitMGUs 0 e.MGUs>;
    1 (assign (e.pardata)(e.Val1)(e.Val2)) e.MGUs = (assign (e.pardata)(e.Val2))<SplitMGUs 1 e.MGUs>;
}


/*Преобразование слоистого стека в список конечных списков имён функций
((t.FunName^+)^*)((assign (var l t.id)(e.Val))^+)^* => (t.FunName^+)^* 
*/
StackForm4TurRel {
/*1. Весь стек обработан, на верхнем уровне вызовов не было.*/
    (e.NewForm)() = e.NewForm;
/*2. Весь стек обработан, на верхнем уровне вызовы имелись.*/
    (e.NewForm)(e.NewTerm) = e.NewForm;
/*3. Текущий слой стека исчерпан без формирования нового терма -- списка вызовов функций (на слое были только объектные выражения).*/
    (e.NewForm)()()e.OtherLevels = <StackForm4TurRel (e.NewForm ((Constant 0)))()e.OtherLevels>;
/*4. Текущий слой стека исчерпан, сформирован список вызовов функций в нем. Помещаем этот список в плоскую форму и переходим к другому слою.*/
    (e.NewForm)(e.NewTerm)()e.OtherLevels = <StackForm4TurRel (e.NewForm (e.NewTerm))()e.OtherLevels>;
/*5. Вставляем имя функции в терм, перечисляющий все имена вызванных функций на слое.*/
    (e.NewForm)(e.NewTerm)((assign (var l t.name)((call (t.fname t.timestamp) e.call)))e.ThisLevel)e.OtherLevels = 
        <StackForm4TurRel (e.NewForm)(<InsertNewFunName (t.fname t.timestamp) e.NewTerm>)(e.ThisLevel)e.OtherLevels>;
/*6. Если очередная стековая переменная не есть вызов, игнорируем ее.*/
    (e.NewForm)(e.NewTerm)((assign (var l t.name)(e.NotCall))e.ThisLevel)e.OtherLevels = 
        <StackForm4TurRel (e.NewForm)(e.NewTerm)(e.ThisLevel)e.OtherLevels>;
}

/*Вставка имени функции в список, если его там еще не было.
t.NewName t.name^* => t.name^*
*/
InsertNewFunName {
	(t.fname t.timestamp1) e.Names1 (t.fname t.timestamp2) e.Names2 = e.Names1 (t.fname t.timestamp1) e.Names2;
	t.fname e.Names = e.Names t.fname;
}

/*
Проверка, вкладывается ли информация узла в информацию о другом узле 
по композиции отношений на стеках, уравнениях и термах. 
((e.Equations)(e.Config)(e.Stack))((e.Equations)(e.Config)(e.Stack)) => s.Log
*/
EmbeddingConfs {
/*
	((e.Equations)(e.Config)(e.Stack))((e.Equations2)(e.Config2)(e.Stack2)) =
		<LogAnd <SingleGapFHE (e.Stack)e.Stack2>
			<LogAnd 
				<HomeomorphicEmb (e.Config)e.Config2>
				<FHE4AllEqs 
					(<CurrentIndex 'EqGen_Complex'>)
					(e.Equations)(e.Equations2)
				>
			>
		>;*/
        ((e.Config)(e.Stack))((e.Config2)(e.Stack2)) =
		<CheckEmb (e.Stack)(e.Stack2)<SingleGapFHE (<Put 1 <StackForm4TurRel ()()e.Stack>>)
                                            <Putout 1 ' and '>
                                        <Put 1 <StackForm4TurRel ()()e.Stack2>>>
			<HomeomorphicEmb (<Put 1 e.Config>)<Putout 1 ' and '><Put 1 e.Config2>>
		>;
}

CheckEmb {
    e.1 'F' e.2 = 'F';
    (e.Stack)(e.Stack2)s.1 'T',
    <ReplaceStackLevelWithNewPar (s.1)(e.Stack)> : (e.asg)(e.Bottom1),
    <ReplaceStackLevelWithNewPar (s.1)(e.Stack2)> : (e.asg2)(e.Bottom2)
    = s.1<HomeomorphicEmb (e.Bottom1)e.Bottom2>;
}

/*Проверка на одноразрывное отношение в строке.
Начинаться обе строки должны с одного и того же терма.
([Term]^*)[Term]^* => s.Log */
SingleGapFHE {
	(((t.1 t.TS1) e.1) e.11) ((t.1 t.TS2) e.21) e.22 = <TurRelat (0)(e.11) e.22>; 
	e.X = 'F';
}

TurRelat {
    (s.Depth)(e.1 t.1) e.2 t.1 = <TurRelat (s.Depth)(e.1) e.2>;
    (s.Depth)(e.1) e.2 = <TurRelatAux (s.Depth)(e.1) e.2>;
}

TurRelatAux {
    (s.Depth)() e.2 = s.Depth;
    (s.Depth)(((t.1 t.TS1) e.11) e.1)((t.1 t.TS2) e.12) e.2 = <TurRelatAux (<MyInc s.Depth>)(e.1)e.2>;
    (s.Depth)(e.1) e.2 = 'F';
}

/*Проверка, вкладывается ли выражение [Expr1] в выражение [Expr2] по Крускалу.
Это гомеоморфное вложение примитивное --- оно не различает имена параметров.
([Expr1])[Expr2] => s.Log*/
$ENTRY HomeomorphicEmb {
        ()e.2 = 'T';
	(e.1) = 'F';
/*0. Равное вкладывается в равное*/
        (t.1)t.1 = 'T';
/*1. Два параметра одного типа всегда вкладываются друг в друга*/
	((par s.type e.par1))(par s.type e.par2) = 'T';
/*2. В переменную/параметр строкового типа вкладывается всё, что угодно.*/
/*	(e.Expr)t.Term, <IsFreeParameter t.Term>:'T' = 'T';*/
/*3. вызов f вкладывается в вызов f, если аргумент вкладывается в аргумент*/
        ((call t.fdata1 (args (arg e.call1))))(call t.fdata2 (args (arg e.call2))),
        t.fdata1 : (t.fname t.TS1), t.fdata2 : (t.fname t.TS2) =
		<HomeomorphicEmb (e.call1)e.call2>;
/*4. В переменную термового типа вкладывается любой терм, кроме вызова и строковой переменной.*/
/*	(t.Term)(weval t t.name), <IsFreeExpression t.Term>:'F' = 'T';*/
/*5. выражение, не имеющее вызова f во внешней части, вкладывается в вызов f, если вкладывается в его аргумент*/
        (e.Expr1)(call t.fname2 (args (arg e.call2))) =
                <HomeomorphicEmb (e.Expr1) e.call2>;
/*6. выражение в скобках.*/
    (('*' e.11))('*' e.21) = <HomeomorphicEmb (e.11)e.21>;

/*6. выражение в скобках и термы.*/
  /*  (('*' e.11)e.12)('*' e.21)e.22 = <LogOr <LogAnd <HomeomorphicEmb (e.11)e.21><HomeomorphicEmb (e.12)e.22>>
                                        <LogOr <HomeomorphicEmb (('*' e.11)e.12) e.21><HomeomorphicEmb (('*' e.11)e.12) e.22>>>;*/

/*7. Все прочее - выражение в скобках
вкладывается, если вкладывается либо в скобки, либо во внешнюю часть*/
    (e.11)('*' e.21) =
		<HomeomorphicEmb (e.11)e.21>;
/*8. Неравное не вкладывается в неравное. 
Здесь t.2 --- не вызов (см. пр-е 5), не скобочное выражение (см. пр-е 7).*/
        (t.1 e.1)t.2 = 'F';
/*9. терм + что-то ещё - терм+что-то ещё вкладываются либо последовательно;
либо все вместе в терм, либо все вместе в что-то ещё. */
        (t.1 e.otherConf1)t.2 e.otherConf2 =
                <KruskalAux2 
                    <HomeomorphicEmb (t.1 e.otherConf1)t.2>
                    (t.1 e.otherConf1)t.2 e.otherConf2
                >;
} /*HomeomorphicEmb*/

/*Вспомогательная функция, имитирующая ленивое исполнение функции LogOr*/
/*KruskalAux {
    'T'e.1 = 'T';
    'F'(e.11)e.22 = <HomeomorphicEmb (e.11)e.22>;
}*/

/*Вспомогательная функция HomeomorphicEmb, имитирующая ленивое исполнение функции LogOr. Предложение 10.*/
KruskalAux2 {
    'T'e.1 = 'T';
    'F'(t.1 e.otherConf1)t.2 e.otherConf2 = 
         <HomeomorphicEmb
                        <IfThenElse 
                            <HomeomorphicEmb (t.1)t.2>
                            ((e.otherConf1)e.otherConf2) 
                            (t.1 e.otherConf1) e.otherConf2
                        >
        >;
}

/*s.Log (e.1)e.2*/
IfThenElse {
    'T'(e.1) e.2 = e.1;
    'F'(e.1) e.2 = e.2;
}

/*Проверка вложения по уравнениям
[Equation] ::= (AreEqual (([MultiSet])([Expression]))(([MultiSet])([Expression]))) 
([Card])([Equation]^*)([Equation]^*) => s.Log
[Card] --- натуральное число или Inf.
*/
FHE4AllEqs {
/*1. Все уравнения исчерпаны.*/
	(t.EqGenComplexity)()(e.Eqs2) = 'T';
/*2. Если уравнение в первом аргументе имеет сложность меньше или равную ограничивающей, 
оно должно вкладываться в какое-нибудь уравнение во втором аргументе. */
	(t.EqGenComplexity)((e.Equation1)e.OtherEqs1)(e.Eqs2), <MyIfNotLess t.EqGenComplexity <EqGenComplexity e.Equation1>>:'T' =
		<LogAnd
			<HomeomorphicEmb4Equations ((e.Equation1))e.Eqs2>
			<FHE4AllEqs (t.EqGenComplexity)(e.OtherEqs1)(e.Eqs2)>
		>;
/*3. Если уравнение в первом аргументе имеет более высокую сложность, его игнорируем. */
	(t.EqGenComplexity)((e.Equation1)e.OtherEqs1)(e.Eqs2) =
			<FHE4AllEqs (t.EqGenComplexity)(e.OtherEqs1)(e.Eqs2)>;
}

/*Проверка вложимости уравнения в группу уравнений.
Выполняется, если уравнение вкладывается в какое-либо уравнение из группы гомеоморфно,
причём либо левая часть в правую и наоборот, либо левая в левую и правая в правую.
[Equation] [Equation]^* => s.Log
*/
HomeomorphicEmb4Equations {
	t.Eq  = 'F';
	t.Eq1 t.Eq2 e.OtherEqs, 
	t.Eq1 : (AreEqual ((e.CompLHS1)(e.LHS1))((e.CompRHS1)(e.RHS1))), 
	t.Eq2 : (AreEqual ((e.CompLHS2)(e.LHS2))((e.CompRHS2)(e.RHS2))) =
		<LogOr
			<LogOr 
				<LogAnd
					<HomeomorphicEmb (e.LHS1)e.LHS2>
					<HomeomorphicEmb (e.RHS1)e.RHS2>
				>
				<LogAnd
					<HomeomorphicEmb (e.RHS1)e.LHS2>
					<HomeomorphicEmb (e.LHS1)e.RHS2>
				>
			>
			<HomeomorphicEmb4Equations t.Eq1 e.OtherEqs>
		>;
}

/*Функция вычисления сложности уравнения.
Сложность уравнения --- это суммарное количество вхождений в него всех параметров.
Здесь также считается, что если в уравнение входит строковая переменная (не параметр), оно имеет сложность Nat (Inf).
Поэтому такие уравнения всегда игнорируются (упрощение!).
[Equation] => [Card]
*/
EqGenComplexity {
	(AreEqual ((e.CompLHS)(e.LHS))((e.CompRHS)(e.RHS))) =
		<MyAdd <SEGCompl e.CompLHS><SEGCompl e.CompRHS>>;
}

/*Функция вычисления сложности одной части уравнения.
[MultiSet] => [Card]
*/
SEGCompl {
	 = <MyZero>;
	(t.Power (weval e.Z)) e.Other = Inf;
	(t.Power t.Name) e.Other = <MyAdd t.Power <SEGCompl e.Other>>;
}

/*([Pattern])((assign (e.Name) (ToUnify (e.1)(e.2)) => ([Pattern])((assign (e.Name) (ToUnify (e.1)(e.2))
Самый первый вызов --- [Pattern] всегда e-параметр. */
FindMaxContext {
/*0. Обобщать больше нечего. Этой ситуации в программе быть не должно, выделена для теста!*/
/*    (e.Pattern)((ToUnify ()())) = (e.Pattern)(); */

/*1a. Полностью одинаковые термы слева образуют общий контекст.*/
    (e.Pattern)((assign (e.Name)(ToUnify (t.1 e.1)(t.1 e.2)))) = 
        <FindMaxContext 
            (<Substitute ((assign (e.Name)(t.1 (e.Name)))) e.Pattern>)
            ((assign (e.Name)(ToUnify (e.1)(e.2))))
        >;
/*1б. Полностью одинаковые термы справа образуют общий контекст.*/
    (e.Pattern)((assign (e.Name)(ToUnify (e.1 t.1)(e.2 t.1)))) = 
        <FindMaxContext 
            (<Substitute ((assign (e.Name)((e.Name) t.1))) e.Pattern>)
            ((assign (e.Name)(ToUnify (e.1)(e.2))))
        >;
/*2. Одинаковые вызовы функций, если кроме этих функций на данном уровне ничего нет, также образуют общий контекст.*/
    (e.Pattern)((assign (e.Name)(ToUnify ((call t.fname (args (arg e.1))))((call t.fname (args (arg e.2))))))) = 
        <FindMaxContext 
            (<Substitute ((assign (e.Name)((call t.fname (args (arg (e.Name))))))) e.Pattern>)
            ((assign (e.Name)(ToUnify (e.1)(e.2))))
        >;
/*3. Во всех остальных случаях общего контекста нет.*/
    (e.Pattern)(e.ToUnify) = (e.Pattern)(e.ToUnify);
}

/*----------------------------------------------------------------------------------------------------------------------------
Most Generic Unification для ассоциативных данных

[MGUSub] ::= (assign (par s.type t.name)([Expr1])([Expr2]))
[ToUnify] ::= (assign t.Name (ToUnify ([Expr])([Epr])))

([Expr])([ToUnify]^*)([MGUSub]^*)
=>
([Expr])([MGUSub]^*)

1ый аргумент --- текущий вариант Most Generic Unification (шаблон).
2ой аргумент --- список кусков --- параметров из первого аргумента, которые ещё нужно обобщить.
3ий аргумент --- текущий набор порожденных подстановок.
-------------------------------------------------------------------------------------------------------------------------------*/
$ENTRY MGUAssoc {
/*1. Обобщать больше нечего.*/
    (e.Pattern)()(e.MGUs) = (e.Pattern)(e.MGUs); 
/*2. Обобщаются равные выражения --- это выражение просто подставляется в шаблон вместо параметра.*/
    (e.Pattern)(e.Other1 (assign (par e t.Name)(ToUnify t.val t.val))e.Other)(e.MGUs) =
        <MGUAssoc (<Substitute ((assign (par e t.Name)t.val)) e.Pattern>)(e.Other1 e.Other)(e.MGUs)>;
/*3. Обобщаются термы, вызовы, параметры либо выражения в скобках --- передача управления MGUObject.*/
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1)(t.Object2)))e.Other)(e.MGUs),
    <HomeomorphicEmb (t.Object1) t.Object2> : 'T' = 
            <MGUAssoc
                <MGUObject (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1)(t.Object2)))e.Other)
                    (e.MGUs)
                >
            >;
/*4. Пустое выражение обобщается с непустым --- до e-выражения*/
    (e.Pattern)((assign (par e t.Name)(ToUnify ()(e.Object)))e.Other)
        (e.MGUs) = 
            <MGUAssoc <IntroduceEMGU (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)(assign (par e t.Name)()(e.Object))(e.Pattern)(e.Other)(e.MGUs)
            >>;
/*4. Пустое выражение обобщается с непустым --- до e-выражения*/
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object)))e.Other)(e.MGUs),
	<HomeomorphicEmb (t.Object1 e.Expr1)t.Object> : 'T' = 
            <MGUAssoc <IntroduceEMGU (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)(assign (par e t.Name)(t.Object1 e.Expr1)(t.Object))(e.Pattern)(e.Other)(e.MGUs)
            >>;
	(e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object)))e.Other)(e.MGUs),
	<HomeomorphicEmb (t.Object1 e.Expr1)t.Object> : 'F' = (False)(False); 
            
/*4а. Пустое выражение обобщается с непустым --- до e-выражения*/
  /*  (e.Pattern)((assign (par e t.Name)(ToUnify (e.Object)()))e.Other)
        (e.MGUs) = 
            <MGUAssoc <IntroduceEMGU (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)(assign (par e t.Name)(e.Object)())(e.Pattern)(e.Other)(e.MGUs)
            >>;*/
/*5. Все остальные случаи: либо объекты обобщаются друг с другом, остальное друг с другом, либо объект + выражение со всем, другой объект - с пустым*/
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object2 e.Expr2)))e.Other)(e.MGUs),
    <HomeomorphicEmb (t.Object1)t.Object2> : 'T' = 
            <MinMGU
                    (<MGUAssoc <ProceedMGU 
                        (<FreshIndex 'pare_ind'>)(<FreshIndex 'pare_ind'>)
                        (par e t.Name)
                        ((t.Object1)(t.Object2))
                        ((e.Expr1)(e.Expr2))
                        (e.Pattern)
                        (e.Other)
                        (e.MGUs)
                >>)
                (<MinMGU    
                    (<MGUAssoc <ProceedMGU 
                        (<FreshIndex 'pare_ind'>)(<FreshIndex 'pare_ind'>)
                        (par e t.Name)
                        (()(t.Object2))
                        ((t.Object1 e.Expr1)(e.Expr2))
                        (e.Pattern)
                        (e.Other)
                        (e.MGUs)
                >>)
			(<MGUAssoc <ProceedMGU 
                        (<FreshIndex 'pare_ind'>)(<FreshIndex 'pare_ind'>)
                        (par e t.Name)
                        (()(e.Expr2))
                        ((t.Object1 e.Expr1)(t.Object2))
                        (e.Pattern)
                        (e.Other)
                        (e.MGUs)
                >>)
                >)
		>;
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object2 e.Expr2)))e.Other)
        (e.MGUs) = 
                <MGUAssoc <ProceedMGU 
                        (<FreshIndex 'pare_ind'>)(<FreshIndex 'pare_ind'>)
                        (par e t.Name)
                        (()(t.Object2))
                        ((t.Object1 e.Expr1)(e.Expr2))
                        (e.Pattern)
                        (e.Other)
                        (e.MGUs)
                >>;
    (e.Pattern)(e.ToUnify)(e.MGUs) = (False)(False); 
}/*MGUAssoc*/

/*Функция передачи построения обобщения другой функции.
(t.ParName)(t.ParName)(par e t.Name)(([Expr1])([Expr2]))([Expr3])([Expr4])([ExprPattern])([ToUnify])([MGUSub]^*) =>
([Expr])([ToUnify]^*)([MGUSub]^*)
Первые два имени --- два новых имени переменных, на которых разбивается третья.
*/
ProceedMGU {
/*1. Передаем управление MGUObject*/
    (t.NewName1)(t.NewName2)(par e t.Name)((t.Expr11)(t.Expr12))((e.Expr21)(e.Expr22))(e.Pattern)(e.ToUnify)(e.MGUs) =
                    <MGUObject 
                        (<Substitute ((assign (par e t.Name)((par e t.NewName1)(par e t.NewName2))))e.Pattern>)
                        (
                            (assign (par e t.NewName1) (ToUnify (t.Expr11)(t.Expr12)))
                            (assign (par e t.NewName2) (ToUnify (e.Expr21)(e.Expr22))) 
                            e.ToUnify
                        )
                        (e.MGUs)
                    >;
/*1. Передаем управление IntroduceEMGU*/
    (t.NewName1)(t.NewName2)(par e t.Name)((e.Expr11)(e.Expr12))((e.Expr21)(e.Expr22))(e.Pattern)(e.ToUnify)(e.MGUs) =
                    <IntroduceEMGU 
                        (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
                        (assign (par e t.NewName1)(e.Expr11)(e.Expr12))
                        (<Substitute ((assign (par e t.Name)((par e t.NewName1)(par e t.NewName2))))e.Pattern>)
                        ((assign (par e t.NewName2) (ToUnify (e.Expr21)(e.Expr22))) e.ToUnify)
                        (e.MGUs)
                    >;
 /*   (t.NewName1)(t.NewName2)(par e t.Name)(e.E1)(e.E2)(e.Pattern)(e.ToUnify)(e.MGUs) = (False)()(False);*/
}

/*Обобщение двух единичных термов
([Expr])((assign (par e t.Name)([Term])([Term]))[ToUnify]^*)([MGUSub]^*) =>
([Expr])([ToUnify]^*)([MGUSub]^*)
*/
MGUObject {
/*1. Обобщение двух равных термов --- просто подстановка терма вместо е-переменной*/
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Val)(t.Val)))e.Other)(e.MGUs) =
                    (<Substitute ((assign (par e t.Name)(t.Val)))e.Pattern>)
                    (e.Other)
                    (e.MGUs);

/*2. Обобщение двух разных символов или s-параметров до s-параметра (4 случая)*/
    (e.Pattern)((assign (par e t.Name)(ToUnify (s.Sym1)(s.Sym2)))e.Other)(e.MGUs) =
                    <ProceedNewObjectMGU 
                        (par s <FreshIndex 'pars_ind'>)
                        (e.Pattern)((assign (par e t.Name)(ToUnify (s.Sym1)(s.Sym2)))e.Other)(e.MGUs)
                    >;
    (e.Pattern)((assign (par e t.Name)(ToUnify (s.Sym1)((par s t.sname))))e.Other)(e.MGUs) =
                    <ProceedNewObjectMGU 
                        (par s <FreshIndex 'pars_ind'>)
                        (e.Pattern)((assign (par e t.Name)(ToUnify (s.Sym1)((par s t.sname))))e.Other)(e.MGUs)
                    >;
/*    (e.Pattern)((assign (par e t.Name)(ToUnify ((par s t.sname))(s.Sym2)))e.Other)(e.MGUs) =
                    <ProceedNewObjectMGU 
                        (par s <FreshIndex 'pars_ind'>)
                        (e.Pattern)((assign (par e t.Name)(ToUnify ((par s t.sname))(s.Sym2)))e.Other)(e.MGUs)
                    >;*/
    (e.Pattern)((assign (par e t.Name)(ToUnify ((par s t.sname1))((par s t.sname2))))e.Other)(e.MGUs) =
                    <ProceedNewObjectMGU 
                        (par s <FreshIndex 'pars_ind'>)
                        (e.Pattern)((assign (par e t.Name)(ToUnify ((par s t.sname1))((par s t.sname2))))e.Other)(e.MGUs)
                    >;
/*3. Обобщение двух вызовов одинаковых функций до вызова функции*/
    (e.Pattern)((assign (par e t.Name)(ToUnify ((call (t.fname t.TS1) (args (arg e.Arg1))))((call (t.fname t.TS2) (args (arg e.Arg2))))))e.Other)(e.MGUs) =
                    (<Substitute ((assign (par e t.Name)((call (t.fname <CurrentIndex 'time_stamp'>) (args (arg (par e t.Name)))))))e.Pattern>)
                    ((assign (par e t.Name)(ToUnify (e.Arg1)(e.Arg2)))e.Other)
                    (e.MGUs)
                    ;
/*4. Обобщение двух выражений в скобках до выражения в скобках*/
    (e.Pattern)((assign (par e t.Name)(ToUnify (('*' e.Expr1))(('*' e.Expr2))))e.Other)(e.MGUs) =
                    (<Substitute ((assign (par e t.Name)(('*' (par e t.Name)))))e.Pattern>)
                    ((assign (par e t.Name)(ToUnify (e.Expr1)(e.Expr2)))e.Other)
                    (e.MGUs)
                    ;
/*5. Вызов функции и что-то ещё обобщаются до e-параметра (2 случая)*/
    (e.Pattern)((assign (par e t.Name)(ToUnify ((call e.call))(e.Expr2)))e.Other)(e.MGUs) =
                    <IntroduceEMGU 
                        (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
                        (assign (par e t.Name)((call e.call))(e.Expr2))(e.Pattern)
                        (e.Other)(e.MGUs)
                    >;
    (e.Pattern)((assign (par e t.Name)(ToUnify (e.Expr1)((call e.call))))e.Other)(e.MGUs) =
                    <IntroduceEMGU 
                        (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
                        (assign (par e t.Name)(e.Expr1)((call e.call)))(e.Pattern)
                        (e.Other)(e.MGUs)
                    >;
/*6. е-параметр и что-то ещё обобщаются до e-параметра (2 случая)*/
    (e.Pattern)((assign (par e t.Name)(ToUnify ((par e t.EName))(e.Expr2)))e.Other)(e.MGUs) =
                    <IntroduceEMGU 
                        (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
                        (assign (par e t.Name)((par e t.EName))(e.Expr2))(e.Pattern)
                        (e.Other)(e.MGUs)
                    >;
    (e.Pattern)((assign (par e t.Name)(ToUnify (e.Expr1)((par e t.EName))))e.Other)(e.MGUs) =
                    <IntroduceEMGU 
                        (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
                        (assign (par e t.Name)(e.Expr1)((par e t.EName)))(e.Pattern)
                        (e.Other)(e.MGUs)
                    >;
/*7. Во всех прочих случаях обобщаемся до t-параметра*/
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Obj1)(t.Obj2)))e.Other)(e.MGUs) =
                    <ProceedNewObjectMGU 
                        (par t <FreshIndex 'part_ind'>)
                        (e.Pattern)((assign (par e t.Name)(ToUnify (t.Obj1)(t.Obj2)))e.Other)(e.MGUs)
                    >;    
}/*MGUObject*/

/*Обобщение до t- или s-параметра.
(par t.type t.NewName)([Expr])([ToUnify2Objects][ToUnify]^*)([MGUSub]^*) => 
([Expr])([ToUnify]^*)([MGUSub]^*)

t.type ::= t|s
*/
ProceedNewObjectMGU {
    (par t.type t.NewName)(e.Pattern)((assign (par e t.Name)(ToUnify (t.Obj1)(t.Obj2)))e.Other)(e.MGUs) =
                <CheckRepeatedMGUs ()(<Substitute ((assign (par e t.Name)((par t.type t.NewName))))e.Pattern>)
                (e.Other)
                (<DeleteMGU (par e t.Name)e.MGUs> (assign (par t.type t.NewName)(t.Obj1)(t.Obj2)))>;
}

AAA { = ;}

/*Введение обобщения до е-переменной.
Если эта e-переменная следует в шаблоне после другой e-переменной, следует их слить.
(t.ParName^*)[MGUSub]([Expr])([ToUnify]^*)([MGUSub]^*) => 
([Expr])([ToUnify]^*)([MGUSub]^*)
*/
IntroduceEMGU {
/*КОСТЫЛЬ! Если нашлась повторная подстановка, стираем возможность сливать переменную*/
    ((e.Arbitrary1)(e.Arbitrary2))(assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs),
    e.MGUs : e.MGUs1 (assign (par e t.OtherName)(e.Expr1)(e.Expr2)) e.MGUs2 =
        <IntroduceEMGU ()(assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs)>;
 /*1. У е-параметра, который обобщаем, в шаблоне ровно 1 предшественник --- тоже е-параметр.
Сливаем эти параметры, после чего проверяем подстановку на повторность.*/
    (((par e t.Name2))(e.Post))(assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs),
        <PatternParameter (par e t.Name2) e.Other> : 'F' =
        <CheckRepeatedMGUs ()<ConcatenateMGUs (1)
            <FindMGU (par e t.Name2) e.MGUs>
            (assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(<DeleteMGU (par e t.Name2) e.MGUs>)
        >>;
    ((e.Pred)((par e t.Name2)))(assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs),
        <PatternParameter (par e t.Name2) e.Other> : 'F' =
        <CheckRepeatedMGUs ()<ConcatenateMGUs (0)
            (assign (par e t.Name)(e.Expr1)(e.Expr2))<FindMGU (par e t.Name2) e.MGUs>(e.Pattern)(e.Other)
            (<DeleteMGU (par e t.Name2) e.MGUs>)
        >>;
/*2. Во всех других случаях просто проверяем новую подстановку на повторность и записываем в список ([MGUSub]^*) (последний аргумент).*/
    (e.Arbitrary)(assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs) =
        <CheckRepeatedMGUs ()(e.Pattern)(e.Other)(<DeleteMGU (par e t.Name) e.MGUs> (assign (par e t.Name)(e.Expr1)(e.Expr2)))>;
}

PatternParameter {
    t.name e.ToUn1 (assign t.name e.Vals) e.ToUn2 = 'T';
    e.other = 'F';
}

/*Проверка, нет ли уже введенного параметра, обе подстановки в который совпадают с имеющимися в [CurrentNewMGUSub].
([MGUSub]^*)([Expr])([ToUnify]^*)[MGUSub]^* [CurrentNewMGUSub] => ([Expr])([ToUnify]^*)([MGUSub]^*)*/
CheckRepeatedMGUs {
/*1. Все подстановки проверены.*/
    (e.Checked)(e.Pattern)(e.ToUnify)((assign (e.pardata) t.Val1 t.Val2)) = (e.Pattern)(e.ToUnify)(e.Checked (assign (e.pardata) t.Val1 t.Val2));
/*2. Нашлась подстановка с такими же значениями --- значит, наша подстановка есть просто подстановка одного е-параметра.*/
    (e.Checked)(e.Pattern)(e.ToUnify)((assign (e.pardata1) t.Val1 t.Val2) e.Other (assign (e.pardata) t.Val1 t.Val2)) =
        (<Substitute ((assign (e.pardata)((e.pardata1))))e.Pattern>)
        (e.ToUnify)
        (e.Checked (assign (e.pardata1) t.Val1 t.Val2) e.Other);
/*3. Пока не нашлась --- ищем дальше.*/
    (e.Checked)(e.Pattern)(e.ToUnify)((assign (e.pardata1) t.Val11 t.Val22) e.Other (assign (e.pardata) t.Val1 t.Val2)) =
        <CheckRepeatedMGUs (e.Checked (assign (e.pardata1) t.Val11 t.Val22))(e.Pattern)(e.ToUnify)(e.Other (assign (e.pardata) t.Val1 t.Val2))>;
}


/*поиск назначения на данный параметр
(par e.pardata)[MGUSub]^* => [MGUSub] */
FindMGU {
/*1. Нашли --- возвращаем.*/
    t.Parameter e.First (assign t.Parameter e.Data)e.Other = (assign t.Parameter e.Data);
/*2. Не нашли --- вызываем тривиальное назначение.*/
    t.Parameter e.Subs = (assign t.Parameter (t.Parameter)(t.Parameter));
}

/*удаление назначения на параметр
(par e.pardata)[MGUSub]^* => [MGUSub]^*
*/
DeleteMGU {
    t.parameter e.First (assign t.parameter e.Data) e.Other = e.First e.Other;
    t.parameter e.Other = e.Other;
}

/*Слияние двух е-параметров в один
[MGUSub][MGUSub]([Expr])([ToUnify]^*)([MGUSub]^*) => ([Expr])([ToUnify]^*)([MGUSub]^*)
*/
ConcatenateMGUs {
    (0)(assign (par e t.Name1)(e.Expr11)(e.Expr12))(assign (par e t.Name2)(e.Expr21)(e.Expr22))(e.Pattern)(e.Other)(e.MGUs) =
        (<Substitute ((assign (par e t.Name2)())) e.Pattern>)(e.Other)
        (e.MGUs (assign (par e t.Name1)(e.Expr11 e.Expr21)(e.Expr12 e.Expr22)));
    (1)(assign (par e t.Name1)(e.Expr11)(e.Expr12))(assign (par e t.Name2)(e.Expr21)(e.Expr22))(e.Pattern)(e.Other)(e.MGUs) =
        (<Substitute ((assign (par e t.Name1)())) e.Pattern>)(e.Other)
        (e.MGUs (assign (par e t.Name2)(e.Expr11 e.Expr21)(e.Expr12 e.Expr22)));
}

FirstEVar {
    (par e e.par) e.other = (par e e.par);
    e.other = 'F';
}

/*Для данного е-параметра ищем предшествующие ему термы в выражении.
Если они все --- один и тот же е-параметр, это отмечается в выходе
(par e t.Name)e.Expr => [(False)|(par e t.Name1)]^*
*/
FindAllPredInPattern {
/*1. Всё смотрено.*/
	(e.Pred)(e.Post)(par e t.Name) = (e.Pred)(e.Post); 
/*2. В шаблоне хотя бы перед одним вхождением этой переменной стоит символ, выражение в скобках, параметр узкого типа или вызов -> 
присоединять не к чему (5 случаев).*/
	(e.Pred)(e.Post)(par e t.Name)t.pred (par e t.Name) e.Expr,
        <FirstEVar t.pred> : 'F', <FirstEVar e.Expr> : 'F' = (False)(False); 
	(e.Pred)(e.Post)(par e t.Name)t.pred (par e t.Name) e.Expr,
        <FirstEVar t.pred> : 'F', <FirstEVar e.Expr> : (par e t.Name2) = 
            <FindAllPredInPattern (e.Pred)(e.Post (par e t.Name2))(par e t.Name) e.Expr>; 
/*3. перед вхождением этого параметра стоит другой е-параметр --- возвращаем его и продолжаем искать дальше.*/
	(e.Pred)(e.Post)(par e t.Name)(par e t.Name2) (par e t.Name) e.Expr,
        <FirstEVar e.Expr> : (par e t.Name3)  = <FindAllPredInPattern (e.Pred (par e t.Name2))(e.Post (par e t.Name3))(par e t.Name) e.Expr>;
/*3. перед вхождением этого параметра стоит другой е-параметр --- возвращаем его и продолжаем искать дальше.*/
	(e.Pred)(e.Post)(par e t.Name)(par e t.Name2) (par e t.Name) e.Expr = 
                                                            <FindAllPredInPattern (e.Pred (par e t.Name2))(e.Post)(par e t.Name) e.Expr>;
/*4. За ближайшим термом не стоит проверяемый параметр --- продолжаем поиск.*/    
	(e.Pred)(e.Post)(par e t.Name)s.Sym e.Expr = <FindAllPredInPattern (e.Pred)(e.Post)(par e t.Name)e.Expr>; 
	(e.Pred)(e.Post)(par e t.Name)('*'e.Expr1) e.Expr,
        <FindAllPredInPattern ()()(par e t.Name)e.Expr1> : (e.Pred1)(e.Post1) = 
            <FindAllPredInPattern (e.Pred e.Pred1)(e.Post e.Post1)(par e t.Name)e.Expr>; 
	(e.Pred)(e.Post)(par e t.Name)(call t.fname (args (arg e.Expr1))) e.Expr,
         <FindAllPredInPattern ()()(par e t.Name)e.Expr1> : (e.Pred1)(e.Post1) = 
            <FindAllPredInPattern (e.Pred e.Pred1)(e.Post e.Post1)(par e t.Name)e.Expr>; 
	(e.Pred)(e.Post)(par e t.Name)(par e.pardata) e.Expr = <FindAllPredInPattern (e.Pred)(e.Post)(par e t.Name)e.Expr>; 
}

/*Выбор обобщения с наибольшим весом. Вес считается как вес (точность) подстановок минус вес (неточность) шаблона.
(([Expr])([MGUSub]^*))(([Expr])([MGUSub]^*)) => (([Expr])([MGUSub]^*))
*/
MinMGU {
    e.MaybeMGU1 ((False)(False)) e.MaybeMGU2, e.MaybeMGU1 e.MaybeMGU2 : (e.CorrectMGU) = e.CorrectMGU;
        ((e.Pattern1)(e.Assignments1))((e.Pattern2)(e.Assignments2)) = 
                    <ChooseLeastMGU 
                        ((e.Pattern1)(e.Assignments1))
                        ((e.Pattern2)(e.Assignments2))
                        <Compare 
                            <Sub <WeightMGU (0)e.Assignments1><WeightPattern (0)e.Pattern1>>
                            <Sub <WeightMGU (0)e.Assignments2><WeightPattern (0)e.Pattern2>>
                        >
                    >;

}

/*Функция назначения весов для полученного обобщения - в доработке!
([Number])[Expr] => [Number]
*/
WeightPattern {
/*1. Все посчитано.*/
    (s.Weight) = s.Weight;
/*2. Символ в шаблоне.*/
    (s.Weight)s.Sym e.Pattern = <WeightPattern (<Add s.Weight 200>) e.Pattern>;
/*3. Символьный параметр в шаблоне.*/
    (s.Weight)(par s e.par) e.Pattern = <WeightPattern (<Add s.Weight 120>) e.Pattern>;
/*4. Скобки в шаблоне.*/
    (s.Weight)e.Pt1 ('*' e.InBracks) e.Pattern = <WeightPattern (<Add s.Weight 80>) e.Pt1 e.InBracks e.Pattern>;
/*5. Термовый параметр в шаблоне.*/
    (s.Weight)(par t e.par) e.Pattern = <WeightPattern (<Add s.Weight 70>) e.Pattern>;
/*6. Вызов функции в шаблоне.*/
    (s.Weight)e.Pt1 (call t.fname (args (arg e.arg))) e.Pattern = <WeightPattern (<Add s.Weight 120>) e.Pt1 e.arg e.Pattern>;
/*7. Худшее --- е-параметр в шаблоне.*/
  /*  (s.Weight)e.Pt1 (par e e.par) e.Pt2 (par e e.par) e.Pattern = <WeightPattern (<Add s.Weight 100>) e.Pt1 e.Pt2 e.Pattern>;*/
    (s.Weight)(par e e.par) e.Pattern = <WeightPattern (s.Weight) e.Pattern>;
}

/*Вспомогательная для MinMGU*/
ChooseLeastMGU {
    ((e.Pattern1)(e.Assignments1))((e.Pattern2)(e.Assignments2))'+' = (e.Pattern2)(e.Assignments2);
    ((e.Pattern1)(e.Assignments1))((e.Pattern2)(e.Assignments2))s.0 = (e.Pattern1)(e.Assignments1);
}

/*Функция назначения веса сопоставлений --- в доработке!!!
([Number])[MGUSub]^* => [Number]
*/
WeightMGU {
/*0. Подстановки "символ - пустое множество" весят мало.*/
    (e.Weight)e.Oth1 (assign (e.Var)()(s.Sym))e.Others =
     <WeightMGU (<Add e.Weight 1>)e.Oth1 e.Others>;
    (e.Weight)e.Oth1 (assign (e.Var)(s.Sym)())e.Others =
     <WeightMGU (<Add e.Weight 1>)e.Oth1 e.Others>;
/*1. Расщепление каждой подстановки на два назначения.*/
    (e.Weight)(assign (e.Var)(e.Val1)(e.Val2))e.Others =
     <WeightMGU (e.Weight)(assign (e.Var)(e.Val1))(assign (e.Var)(e.Val2))e.Others >;
/*2. Прошлись по всем, посчитали.*/
    (e.Weight) = e.Weight;
/*3. Назначение параметру параметра того же типа --- хорошо. Это значит, были повторные подстановки.*/
    (e.Weight)(assign (par s.type t.parname)((par s.type t.parname2)))e.Assignments =
        <WeightMGU (<Sub e.Weight 10>) e.Assignments>;
/*4. Назначение параметру выражения, с двух сторон окруженного е-параметрами.*/
    (e.Weight)(assign (par e t.parname)((par e t.parname2)e.Expr(par e t.parname3)))e.Assignments =
        <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/*5. Назначение параметру выражения, содержащего символ и е-параметр с краю (2 случая).*/
    (e.Weight)(assign (par e t.parname)((par e t.parname2)e.Expr s.Sym))e.Assignments =
        <WeightMGU (<Add e.Weight 20>) e.Assignments>;
    (e.Weight)(assign (par e t.parname)(s.Sym e.Expr (par e t.parname2)))e.Assignments =
        <WeightMGU (<Add e.Weight 20>) e.Assignments>;
/*6. Назначение параметру выражения, содержащего вызов.*/
    (e.Weight)(assign (par e t.parname)((call e.call)))e.Assignments =
        <WeightMGU (<Add e.Weight 5>) e.Assignments>;
/*7. Назначение параметру выражения, содержащего s-параметр и е-параметр с краю (2 случая).*/
    (e.Weight)(assign (par e t.parname)((par e t.parname2)e.Expr(par s t.sparname)))e.Assignments =
        <WeightMGU (<Add e.Weight 15>) e.Assignments>;
    (e.Weight)(assign (par e t.parname)((par s t.sparname)e.Expr(par e t.parname2)))e.Assignments =
        <WeightMGU (<Add e.Weight 15>) e.Assignments>;
/*8. Назначение параметру выражения, содержащего t-параметр либо скобки и е-параметр с краю (2 случая).*/
    (e.Weight)(assign (par e t.parname)((par e t.parname2)e.Expr t.Term))e.Assignments =
        <WeightMGU (<Add e.Weight 10>) e.Assignments>;
    (e.Weight)(assign (par e t.parname)(t.Term e.Expr(par e t.parname2)))e.Assignments =
        <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/*9. Назначение параметру пустого выражения или символа (2 случая).*/
    (e.Weight)(assign (par e t.parname)())e.Assignments =
        <WeightMGU (<Add e.Weight 60>) e.Assignments>;    
    (e.Weight)(assign (par e t.parname)(s.Sym))e.Assignments =
        <WeightMGU (<Add e.Weight 60>) e.Assignments>;    
/*10. Назначение параметру параметра более узкого типа или выражения в скобках - 3 случая.*/
    (e.Weight)(assign (par e t.parname)((par s t.sparname)))e.Assignments =
        <WeightMGU (<Add e.Weight 30>) e.Assignments>;    
    (e.Weight)(assign (par e t.parname)(t.Term))e.Assignments =
        <WeightMGU (<Add e.Weight 20>) e.Assignments>;    
    (e.Weight)(assign (par t t.parname)((par s t.sparname)))e.Assignments =
        <WeightMGU (<Add e.Weight 5>) e.Assignments>;   
/*11. Назначение t-параметру выражения в скобках либо символа.*/
    (e.Weight)(assign (par t t.parname)(t.BracksOrSym))e.Assignments =
        <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/*12. Назначение s-параметру символа.*/	
    (e.Weight)(assign (par s t.parname)(s.Sym))e.Assignments =
        <WeightMGU (<Add e.Weight 5>) e.Assignments>;    
/*13. Назначение e-параметру выражения, содержащего хотя бы один вызов внутри.*/	
    (e.Weight)(assign (par e t.parname)(e.Expr1 (call e.call) e.Expr2))e.Assignments =
        <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/*14. Назначение e-параметру выражения, содержащего термы с двух сторон и е-параметр внутри.*/	
    (e.Weight)(assign (par e t.parname)(e.Expr1 (par e t.parname) e.Expr2))e.Assignments =
        <WeightMGU (<Add e.Weight 20>) e.Assignments>;
/*15. Назначение e-параметру выражения, содержащего лишь объектные выражения либо вызовы.*/	
    (e.Weight)(assign (par e t.parname)(e.Expr))e.Assignments =
        <WeightMGU (<Add e.Weight 30>) e.Assignments>;

}/*WeightMGU*/
